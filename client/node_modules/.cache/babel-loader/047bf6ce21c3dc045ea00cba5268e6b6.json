{"ast":null,"code":"import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = value => value instanceof HTMLElement;\n\nconst EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input'\n};\nconst VALIDATION_MODE = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all'\n};\nconst VALUE = 'value';\nconst SELECT = 'select';\nconst UNDEFINED = 'undefined';\nconst INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate'\n};\n\nfunction attachEventListeners({\n  ref\n}, shouldAttachChangeEvent, handleChange) {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n\nvar isNullOrUndefined = value => value == null;\n\nconst isObjectType = value => typeof value === 'object';\n\nvar isObject = value => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !(value instanceof Date);\n\nvar isKey = value => !Array.isArray(value) && (/^\\w*$/.test(value) || !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar compact = value => value.filter(Boolean);\n\nvar stringToPath = input => compact(input.replace(/[\"|']/g, '').replace(/\\[/g, '.').replace(/\\]/g, '').split('.'));\n\nfunction set(object, path, value) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n    }\n\n    object[key] = newValue;\n    object = object[key];\n  }\n\n  return object;\n}\n\nvar transformToNestObject = (data, value = {}) => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : value[key] = data[key];\n  }\n\n  return value;\n};\n\nvar isUndefined = val => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], obj);\n  return isUndefined(result) || result === obj ? isUndefined(obj[path]) ? defaultValue : obj[path] : result;\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          if (isUndefined(field.ref.focus())) {\n            break;\n          }\n        } else if (field.options) {\n          field.options[0].ref.focus();\n          break;\n        }\n      }\n    }\n  }\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n\nconst defaultReturn = {\n  isValid: false,\n  value: ''\n};\n\nvar getRadioValue = options => Array.isArray(options) ? options.reduce((previous, option) => option && option.ref.checked ? {\n  isValid: true,\n  value: option.ref.value\n} : previous, defaultReturn) : defaultReturn;\n\nvar getMultipleSelectValue = options => [...options].filter(({\n  selected\n}) => selected).map(({\n  value\n}) => value);\n\nvar isRadioInput = element => element.type === 'radio';\n\nvar isFileInput = element => element.type === 'file';\n\nvar isCheckBoxInput = element => element.type === 'checkbox';\n\nvar isMultipleSelect = element => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\n  value: false,\n  isValid: false\n};\nconst validResult = {\n  value: true,\n  isValid: true\n};\n\nvar getCheckboxValue = options => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options.filter(option => option && option.ref.checked).map(({\n        ref: {\n          value\n        }\n      }) => value);\n      return {\n        value: values,\n        isValid: !!values.length\n      };\n    }\n\n    const {\n      checked,\n      value,\n      attributes\n    } = options[0].ref;\n    return checked ? attributes && !isUndefined(attributes.value) ? isUndefined(value) || value === '' ? validResult : {\n      value: value,\n      isValid: true\n    } : validResult : defaultResult;\n  }\n\n  return defaultResult;\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\n  const field = fieldsRef.current[name];\n\n  if (field) {\n    const {\n      ref: {\n        value,\n        disabled\n      },\n      ref\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBoxInput(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n\nfunction isDetached(element) {\n  if (!element) {\n    return true;\n  }\n\n  if (!(element instanceof HTMLElement) || element.nodeType === Node.DOCUMENT_NODE) {\n    return false;\n  }\n\n  return isDetached(element.parentNode);\n}\n\nvar isEmptyObject = value => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = value => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nfunction unset(object, path) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (currentPathsLength === index && (isObject(objectRef) && isEmptyObject(objectRef) || Array.isArray(objectRef) && !objectRef.filter(data => isObject(data) && !isEmptyObject(data) || isBoolean(data)).length)) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\n\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\n  const {\n    ref,\n    ref: {\n      name,\n      type\n    }\n  } = field;\n  const fieldRef = fieldsRef.current[name];\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const {\n      options\n    } = fieldRef;\n\n    if (Array.isArray(options) && options.length) {\n      compact(options).forEach((option, index) => {\n        const {\n          ref\n        } = option;\n\n        if (ref && isDetached(ref) && isSameRef(option, ref) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !compact(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if (isDetached(ref) && isSameRef(fieldRef, ref) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n    delete fieldsRef.current[name];\n  }\n}\n\nfunction setFieldArrayDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setFieldArrayDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\n      } else {\n        get(defaultValues[index] || {}, key) === values[index][key] ? set(dirtyFields[index] || {}, key) : dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), {\n          [key]: true\n        });\n      }\n    }\n\n    !dirtyFields.length && parentNode && delete parentNode[parentName];\n  }\n\n  return dirtyFields.length ? dirtyFields : undefined;\n}\n\nvar isString = value => typeof value === 'string';\n\nvar isPrimitive = value => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] = isObject(targetValue) && isObject(sourceValue) || Array.isArray(targetValue) && Array.isArray(sourceValue) ? deepMerge(targetValue, sourceValue) : sourceValue;\n    } catch (_a) {}\n  }\n\n  return target;\n}\n\nvar getFieldsValues = (fieldsRef, shallowFieldsStateRef, excludeDisabled, search) => {\n  const output = {};\n\n  for (const name in fieldsRef.current) {\n    if (isUndefined(search) || (isString(search) ? name.startsWith(search) : Array.isArray(search) && search.find(data => name.startsWith(data)))) {\n      output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\n    }\n  }\n\n  return deepMerge(transformToNestObject(Object.assign({}, (shallowFieldsStateRef || {}).current || {})), transformToNestObject(output));\n};\n\nfunction deepEqual(object1, object2, isErrorObject) {\n  if (isPrimitive(object1) || isPrimitive(object2)) {\n    return object1 === object2;\n  }\n\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    if (!(isErrorObject && ['ref', 'context'].includes(key))) {\n      const val1 = object1[key];\n      const val2 = object2[key];\n\n      if ((isObject(val1) || Array.isArray(val1)) && (isObject(val2) || Array.isArray(val2)) ? !deepEqual(val1, val2, isErrorObject) : val1 !== val2) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction isErrorStateChanged({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation\n}) {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n  return isValid && !!previousError || !isValid && !deepEqual(previousError, error, true) || isValid && get(fieldsWithValidation, name) && !get(validFields, name);\n}\n\nvar isRegex = value => value instanceof RegExp;\n\nconst isValueMessage = value => isObject(value) && !isRegex(value);\n\nvar getValueAndMessage = validationData => isValueMessage(validationData) ? validationData : {\n  value: validationData,\n  message: ''\n};\n\nvar isFunction = value => typeof value === 'function';\n\nvar isMessage = value => isString(value) || isObject(value) && isValidElement(value);\n\nfunction getValidateError(result, ref, type = 'validate') {\n  if (isMessage(result) || isBoolean(result) && !result) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref\n    };\n  }\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n    return Object.assign(Object.assign({}, error), {\n      types: Object.assign(Object.assign({}, error && error.types ? error.types : {}), {\n        [type]: message || true\n      })\n    });\n  }\n\n  return {};\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, {\n  ref,\n  ref: {\n    type,\n    value\n  },\n  options,\n  required,\n  maxLength,\n  minLength,\n  min,\n  max,\n  pattern,\n  validate\n}, shallowFieldsStateRef) => {\n  const fields = fieldsRef.current;\n  const name = ref.name;\n  const error = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n\n  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = Object.assign({\n      type: exceedMax ? maxType : minType,\n      message,\n      ref\n    }, exceedMax ? appendErrorsCurry(maxType, message) : appendErrorsCurry(minType, message));\n  };\n\n  if (required && (!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value)) || isBoolean(value) && !value || isCheckBox && !getCheckboxValue(options).isValid || isRadio && !getRadioValue(options).isValid)) {\n    const {\n      value: requiredValue,\n      message: requiredMessage\n    } = isMessage(required) ? {\n      value: !!required,\n      message: required\n    } : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox ? ((fields[name].options || [])[0] || {}).ref : ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const {\n      value: maxValue,\n      message: maxMessage\n    } = getValueAndMessage(max);\n    const {\n      value: minValue,\n      message: minMessage\n    } = getValueAndMessage(min);\n\n    if (type === 'number' || !type && !isNaN(value)) {\n      const valueNumber = ref.valueAsNumber || parseFloat(value);\n\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate = ref.valueAsDate || new Date(value);\n\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const {\n      value: patternValue,\n      message: patternMessage\n    } = getValueAndMessage(pattern);\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = Object.assign({\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref\n      }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\n\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {};\n\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(validateResult, validateRef, key);\n\n        if (validateError) {\n          validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = Object.assign({\n          ref: validateRef\n        }, validationResult);\n\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n\nconst getPath = (path, values) => {\n  const getInnerPath = (key, value, isObject) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values).map(([key, value]) => getInnerPath(key, value, isObject(values))).flat(Infinity);\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\n  let value;\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach(name => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value) ? isSingleField ? inputValue : get(inputValue, fieldName) : value;\n};\n\nvar skipValidation = ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n\n  return true;\n};\n\nvar getFieldArrayParentName = name => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\n\nvar isNameInFieldArray = (names, name) => [...names].some(current => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = element => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\n  const observer = new MutationObserver(() => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\n\nfunction cloneObject(data, isWeb) {\n  let copy;\n\n  if (isPrimitive(data) || isWeb && data instanceof File) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n\n    for (const item of data) {\n      copy.add(item);\n    }\n\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key), isWeb));\n    }\n\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key], isWeb);\n  }\n\n  return copy;\n}\n\nvar modeChecker = mode => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched\n});\n\nvar isRadioOrCheckboxFunction = ref => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb = typeof document !== UNDEFINED && !isWindowUndefined && !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nfunction useForm({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {},\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode\n} = {}) {\n  const fieldsRef = useRef({});\n  const fieldArrayDefaultValuesRef = useRef({});\n  const fieldArrayValuesRef = useRef({});\n  const watchFieldsRef = useRef(new Set());\n  const useWatchFieldsRef = useRef({});\n  const useWatchRenderFunctionsRef = useRef({});\n  const fieldsWithValidationRef = useRef({});\n  const validFieldsRef = useRef({});\n  const defaultValuesRef = useRef(defaultValues);\n  const defaultValuesAtRenderRef = useRef({});\n  const isUnMount = useRef(false);\n  const isWatchAllRef = useRef(false);\n  const handleChangeRef = useRef();\n  const shallowFieldsStateRef = useRef(shouldUnregister ? {} : cloneObject(defaultValues, isWeb));\n  const resetFieldArrayFunctionRef = useRef({});\n  const contextRef = useRef(context);\n  const resolverRef = useRef(resolver);\n  const fieldArrayNamesRef = useRef(new Set());\n  const modeRef = useRef(modeChecker(mode));\n  const {\n    isOnSubmit,\n    isOnTouch\n  } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = useState({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {}\n  });\n  const readFormStateRef = useRef({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled\n  });\n  const formStateRef = useRef(formState);\n  const observerRef = useRef();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange\n  } = useRef(modeChecker(reValidateMode)).current;\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n  const updateFormState = useCallback((state = {}) => !isUnMount.current && setFormState(Object.assign(Object.assign({}, formStateRef.current), state)), []);\n  const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\n    let shouldReRender = shouldRender || isErrorStateChanged({\n      errors: formStateRef.current.errors,\n      error,\n      name,\n      validFields: validFieldsRef.current,\n      fieldsWithValidation: fieldsWithValidationRef.current\n    });\n    const previousError = get(formStateRef.current.errors, name);\n\n    if (error) {\n      unset(validFieldsRef.current, name);\n      shouldReRender = shouldReRender || !previousError || !deepEqual(previousError, error, true);\n      set(formStateRef.current.errors, name, error);\n    } else {\n      if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n        set(validFieldsRef.current, name, true);\n        shouldReRender = shouldReRender || previousError;\n      }\n\n      unset(formStateRef.current.errors, name);\n    }\n\n    if (shouldReRender && !isNullOrUndefined(shouldRender) || !isEmptyObject(state)) {\n      updateFormState(Object.assign(Object.assign(Object.assign({}, state), {\n        errors: formStateRef.current.errors\n      }), resolverRef.current ? {\n        isValid: !!isValid\n      } : {}));\n    }\n  }, []);\n  const setFieldValue = useCallback((name, rawValue) => {\n    const {\n      ref,\n      options\n    } = fieldsRef.current[name];\n    const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue) ? '' : rawValue;\n\n    if (isRadioInput(ref) && options) {\n      options.forEach(({\n        ref: radioRef\n      }) => radioRef.checked = radioRef.value === value);\n    } else if (isFileInput(ref) && !isString(value)) {\n      ref.files = value;\n    } else if (isMultipleSelect(ref)) {\n      [...ref.options].forEach(selectRef => selectRef.selected = value.includes(selectRef.value));\n    } else if (isCheckBoxInput(ref) && options) {\n      options.length > 1 ? options.forEach(({\n        ref: checkboxRef\n      }) => checkboxRef.checked = Array.isArray(value) ? !!value.find(data => data === checkboxRef.value) : value === checkboxRef.value) : options[0].ref.checked = !!value;\n    } else {\n      ref.value = value;\n    }\n  }, []);\n  const isFormDirty = useCallback((name, data) => {\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const formValues = getValues();\n      name && data && set(formValues, name, data);\n      return !deepEqual(formValues, isEmptyObject(defaultValuesRef.current) ? defaultValuesAtRenderRef.current : defaultValuesRef.current);\n    }\n\n    return false;\n  }, []);\n  const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\n    if (readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) {\n      const isFieldDirty = !deepEqual(get(defaultValuesAtRenderRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n      const previousIsDirty = formStateRef.current.isDirty;\n      isFieldDirty ? set(formStateRef.current.dirtyFields, name, true) : unset(formStateRef.current.dirtyFields, name);\n      const state = {\n        isDirty: isFormDirty(),\n        dirtyFields: formStateRef.current.dirtyFields\n      };\n      const isChanged = readFormStateRef.current.isDirty && previousIsDirty !== state.isDirty || readFormStateRef.current.dirtyFields && isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name);\n\n      if (isChanged && shouldRender) {\n        formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\n        updateFormState(Object.assign({}, state));\n      }\n\n      return isChanged ? state : {};\n    }\n\n    return {};\n  }, []);\n  const executeValidation = useCallback(async (name, skipReRender) => {\n    if (fieldsRef.current[name]) {\n      const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\n      shouldRenderBaseOnError(name, error, skipReRender);\n      return isUndefined(error);\n    }\n\n    return false;\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const executeSchemaOrResolverValidation = useCallback(async names => {\n    const {\n      errors\n    } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n    const previousFormIsValid = formStateRef.current.isValid;\n\n    if (Array.isArray(names)) {\n      const isInputsValid = names.map(name => {\n        const error = get(errors, name);\n        error ? set(formStateRef.current.errors, name, error) : unset(formStateRef.current.errors, name);\n        return !error;\n      }).every(Boolean);\n      updateFormState({\n        isValid: isEmptyObject(errors),\n        errors: formStateRef.current.errors\n      });\n      return isInputsValid;\n    } else {\n      const error = get(errors, names);\n      shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\n      return !error;\n    }\n  }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\n  const trigger = useCallback(async name => {\n    const fields = name || Object.keys(fieldsRef.current);\n\n    if (resolverRef.current) {\n      return executeSchemaOrResolverValidation(fields);\n    }\n\n    if (Array.isArray(fields)) {\n      !name && (formStateRef.current.errors = {});\n      const result = await Promise.all(fields.map(async data => await executeValidation(data, null)));\n      updateFormState();\n      return result.every(Boolean);\n    }\n\n    return await executeValidation(fields, readFormStateRef.current.isValid);\n  }, [executeSchemaOrResolverValidation, executeValidation]);\n  const setInternalValues = useCallback((name, value, {\n    shouldDirty,\n    shouldValidate\n  }) => {\n    const data = {};\n    set(data, name, value);\n\n    for (const fieldName of getPath(name, value)) {\n      if (fieldsRef.current[fieldName]) {\n        setFieldValue(fieldName, get(data, fieldName));\n        shouldDirty && updateAndGetDirtyState(fieldName);\n        shouldValidate && trigger(fieldName);\n      }\n    }\n  }, [trigger, setFieldValue, updateAndGetDirtyState]);\n  const setInternalValue = useCallback((name, value, config = {}) => {\n    if (fieldsRef.current[name]) {\n      setFieldValue(name, value);\n      config.shouldDirty && updateAndGetDirtyState(name);\n    } else if (!isPrimitive(value)) {\n      setInternalValues(name, value, config);\n\n      if (fieldArrayNamesRef.current.has(name)) {\n        fieldArrayDefaultValuesRef.current[name] = value;\n        resetFieldArrayFunctionRef.current[name]({\n          [name]: value\n        });\n\n        if ((readFormStateRef.current.isDirty || readFormStateRef.current.dirtyFields) && config.shouldDirty) {\n          set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\n          updateFormState({\n            isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), {\n              [name]: value\n            }), defaultValuesRef.current),\n            dirtyFields: formStateRef.current.dirtyFields\n          });\n        }\n      }\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n  }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\n\n  const isFieldWatched = name => isWatchAllRef.current || watchFieldsRef.current.has(name) || watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name, found = true) => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (!name || !useWatchFieldsRef.current[key].size || useWatchFieldsRef.current[key].has(name) || useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue(name, value, config) {\n    setInternalValue(name, value, config);\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n    (config || {}).shouldValidate && trigger(name);\n  }\n\n  handleChangeRef.current = handleChangeRef.current ? handleChangeRef.current : async ({\n    type,\n    target\n  }) => {\n    let name = target.name;\n    const field = fieldsRef.current[name];\n    let error;\n    let isValid;\n\n    if (field) {\n      const isBlurEvent = type === EVENTS.BLUR;\n      const shouldSkipValidation = skipValidation(Object.assign({\n        isBlurEvent,\n        isReValidateOnChange,\n        isReValidateOnBlur,\n        isTouched: !!get(formStateRef.current.touched, name),\n        isSubmitted: formStateRef.current.isSubmitted\n      }, modeRef.current));\n      let state = updateAndGetDirtyState(name, false);\n      let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n      if (isBlurEvent && !get(formStateRef.current.touched, name) && readFormStateRef.current.touched) {\n        set(formStateRef.current.touched, name, true);\n        state = Object.assign(Object.assign({}, state), {\n          touched: formStateRef.current.touched\n        });\n      }\n\n      if (shouldSkipValidation) {\n        renderWatchedInputs(name);\n        return (!isEmptyObject(state) || shouldRender && isEmptyObject(state)) && updateFormState(state);\n      }\n\n      if (resolverRef.current) {\n        const {\n          errors\n        } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\n        const previousFormIsValid = formStateRef.current.isValid;\n        error = get(errors, name);\n\n        if (!error && resolverRef.current) {\n          const parentNodeName = name.substring(0, name.lastIndexOf('.') > name.lastIndexOf('[') ? name.lastIndexOf('.') : name.lastIndexOf('['));\n          const currentError = get(errors, parentNodeName, {});\n          currentError.type && currentError.message && (error = currentError);\n\n          if (parentNodeName && (currentError || get(formStateRef.current.errors, parentNodeName))) {\n            name = parentNodeName;\n          }\n        }\n\n        isValid = isEmptyObject(errors);\n\n        if (previousFormIsValid !== isValid) {\n          shouldRender = true;\n        }\n      } else {\n        error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\n      }\n\n      renderWatchedInputs(name);\n      shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n    }\n  };\n\n  function setFieldArrayDefaultValues(data) {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data, isWeb);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = Object.assign(Object.assign({}, copy), {\n            [value]: []\n          });\n        }\n      }\n\n      return copy;\n    }\n\n    return data;\n  }\n\n  function getValues(payload) {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef));\n  }\n\n  const validateResolver = useCallback(async (values = {}) => {\n    const {\n      errors\n    } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\n    const isValid = isEmptyObject(errors);\n    formStateRef.current.isValid !== isValid && updateFormState({\n      isValid\n    });\n  }, [isValidateAllFieldCriteria]);\n  const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\n  const updateWatchedValue = useCallback(name => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n  const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\n    if (field) {\n      removeFieldEventListener(field, forceDelete);\n\n      if (shouldUnregister && !compact(field.options || []).length) {\n        unset(defaultValuesAtRenderRef.current, field.ref.name);\n        unset(validFieldsRef.current, field.ref.name);\n        unset(fieldsWithValidationRef.current, field.ref.name);\n        unset(formStateRef.current.errors, field.ref.name);\n        set(formStateRef.current.dirtyFields, field.ref.name, true);\n        updateFormState({\n          errors: formStateRef.current.errors,\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields\n        });\n        readFormStateRef.current.isValid && resolverRef.current && validateResolver();\n        updateWatchedValue(field.ref.name);\n      }\n    }\n  }, [validateResolver, removeFieldEventListener]);\n\n  function clearErrors(name) {\n    name && (Array.isArray(name) ? name : [name]).forEach(inputName => fieldsRef.current[inputName] && isKey(inputName) ? delete formStateRef.current.errors[inputName] : unset(formStateRef.current.errors, inputName));\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {}\n    });\n  }\n\n  function setError(name, error) {\n    const ref = (fieldsRef.current[name] || {}).ref;\n    set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), {\n      ref\n    }));\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors\n    });\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\n    const watchFields = watchId ? useWatchFieldsRef.current[watchId] : watchFieldsRef.current;\n    const combinedDefaultValues = isUndefined(defaultValue) ? defaultValuesRef.current : defaultValue;\n    let fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, false, fieldNames);\n\n    if (isString(fieldNames)) {\n      if (fieldArrayNamesRef.current.has(fieldNames)) {\n        const fieldArrayValue = get(fieldArrayValuesRef.current, fieldNames, []);\n        fieldValues = fieldArrayValue.length !== compact(get(fieldValues, fieldNames, [])).length || !fieldArrayValue.length ? fieldArrayValuesRef.current : fieldValues;\n      }\n\n      return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue) ? get(combinedDefaultValues, fieldNames) : defaultValue, true);\n    }\n\n    if (Array.isArray(fieldNames)) {\n      return fieldNames.reduce((previous, name) => Object.assign(Object.assign({}, previous), {\n        [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues)\n      }), {});\n    }\n\n    isWatchAllRef.current = isUndefined(watchId);\n    return transformToNestObject(!isEmptyObject(fieldValues) && fieldValues || combinedDefaultValues);\n  }, []);\n\n  function watch(fieldNames, defaultValue) {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(name) {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef(ref, validateOptions = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn('📋 Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\n      }\n\n      if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) && !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(ref.name)) {\n        return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const {\n      name,\n      type,\n      value\n    } = ref;\n    const fieldRefAndValidationOptions = Object.assign({\n      ref\n    }, validateOptions);\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n    const compareRef = currentRef => isWeb && (!isHTMLElement(ref) || currentRef === ref);\n\n    let field = fields[name];\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (field && (isRadioOrCheckbox ? Array.isArray(field.options) && compact(field.options).find(option => {\n      return value === option.ref.value && compareRef(option.ref);\n    }) : compareRef(field.ref))) {\n      fields[name] = Object.assign(Object.assign({}, field), validateOptions);\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox ? Object.assign({\n        options: [...compact(field && field.options || []), {\n          ref\n        }],\n        ref: {\n          type,\n          name\n        }\n      }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n    const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(isEmptyUnmountFields ? defaultValuesRef.current : shallowFieldsStateRef.current, name);\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then(error => {\n          const previousFormIsValid = formStateRef.current.isValid;\n          isEmptyObject(error) ? set(validFieldsRef.current, name, true) : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (!defaultValuesAtRenderRef.current[name] && !(isFieldArray && isEmptyDefaultValue)) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue ? isObject(fieldValue) ? Object.assign({}, fieldValue) : fieldValue : defaultValue);\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(isRadioOrCheckbox && field.options ? field.options[field.options.length - 1] : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\n    }\n  }\n\n  function register(refOrValidationOptions, rules) {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({\n          name: refOrValidationOptions\n        }, rules);\n      } else if (isObject(refOrValidationOptions) && 'name' in refOrValidationOptions) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return ref => ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = useCallback((onValid, onInvalid) => async e => {\n    if (e && e.preventDefault) {\n      e.preventDefault();\n      e.persist();\n    }\n\n    let fieldErrors = {};\n    let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef, true));\n    readFormStateRef.current.isSubmitting && updateFormState({\n      isSubmitting: true\n    });\n\n    try {\n      if (resolverRef.current) {\n        const {\n          errors,\n          values\n        } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\n        formStateRef.current.errors = fieldErrors = errors;\n        fieldValues = values;\n      } else {\n        for (const field of Object.values(fieldsRef.current)) {\n          if (field) {\n            const {\n              ref: {\n                name\n              }\n            } = field;\n            const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\n\n            if (fieldError[name]) {\n              set(fieldErrors, name, fieldError[name]);\n              unset(validFieldsRef.current, name);\n            } else if (get(fieldsWithValidationRef.current, name)) {\n              unset(formStateRef.current.errors, name);\n              set(validFieldsRef.current, name, true);\n            }\n          }\n        }\n      }\n\n      if (isEmptyObject(fieldErrors) && Object.keys(formStateRef.current.errors).every(name => name in fieldsRef.current)) {\n        updateFormState({\n          errors: {},\n          isSubmitting: true\n        });\n        await onValid(fieldValues, e);\n      } else {\n        formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\n        onInvalid && (await onInvalid(formStateRef.current.errors, e));\n        shouldFocusError && focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n      }\n    } finally {\n      updateFormState({\n        isSubmitted: true,\n        isSubmitting: false,\n        isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n        errors: formStateRef.current.errors,\n        submitCount: formStateRef.current.submitCount + 1\n      });\n    }\n  }, [shouldFocusError, isValidateAllFieldCriteria]);\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields\n  }) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false\n    });\n  };\n\n  const reset = (values, omitResetState = {}) => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const {\n            ref,\n            options\n          } = field;\n          const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options) ? options[0].ref : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form').reset();\n              break;\n            } catch (_a) {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = cloneObject(values || defaultValuesRef.current, isWeb);\n    values && renderWatchedInputs('');\n    Object.values(resetFieldArrayFunctionRef.current).forEach(resetFieldArray => isFunction(resetFieldArray) && resetFieldArray());\n    shallowFieldsStateRef.current = shouldUnregister ? {} : cloneObject(values, isWeb) || {};\n    resetRefs(omitResetState);\n  };\n\n  useEffect(() => {\n    isUnMount.current = false;\n    resolver && readFormStateRef.current.isValid && validateResolver();\n    observerRef.current = observerRef.current || !isWeb ? observerRef.current : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n    return () => {\n      isUnMount.current = true;\n      observerRef.current && observerRef.current.disconnect();\n      shallowFieldsStateRef.current = {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach(field => removeFieldEventListenerAndRef(field, true));\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid = deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) && isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: useCallback(setValue, [setInternalValue, trigger]),\n    getValues: useCallback(getValues, []),\n    register: useCallback(register, [defaultValuesRef.current]),\n    unregister: useCallback(unregister, [])\n  };\n  const control = useMemo(() => Object.assign({\n    isFormDirty,\n    updateWatchedValue,\n    shouldUnregister,\n    updateFormState,\n    removeFieldEventListener,\n    watchInternal,\n    mode: modeRef.current,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    validateResolver: resolver ? validateResolver : undefined,\n    fieldsRef,\n    resetFieldArrayFunctionRef,\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    fieldArrayDefaultValuesRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayNamesRef,\n    readFormStateRef,\n    formStateRef,\n    defaultValuesRef,\n    shallowFieldsStateRef,\n    fieldArrayValuesRef\n  }, commonProps), [defaultValuesRef.current, updateWatchedValue, shouldUnregister, removeFieldEventListener, watchInternal]);\n  return Object.assign({\n    watch,\n    control,\n    formState: isProxyEnabled ? new Proxy(formState, {\n      get: (obj, prop) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (prop === 'isValid' && isOnSubmit) {\n            console.warn('📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\n          }\n        }\n\n        if (prop in obj) {\n          readFormStateRef.current[prop] = true;\n          return obj[prop];\n        }\n\n        return undefined;\n      }\n    }) : formState,\n    handleSubmit,\n    reset: useCallback(reset, []),\n    clearErrors: useCallback(clearErrors, []),\n    setError: useCallback(setError, []),\n    errors: formState.errors\n  }, commonProps);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nconst FormContext = createContext(null);\nFormContext.displayName = 'RHFContext';\n\nconst useFormContext = () => useContext(FormContext);\n\nconst FormProvider = _a => {\n  var {\n    children\n  } = _a,\n      props = __rest(_a, [\"children\"]);\n\n  return createElement(FormContext.Provider, {\n    value: Object.assign({}, props)\n  }, children);\n};\n\nvar generateId = () => {\n  const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n};\n\nconst removeAt = (data, index) => [...data.slice(0, index), ...data.slice(index + 1)];\n\nfunction removeAtIndexes(data, index) {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return compact(data);\n}\n\nvar removeArrayAt = (data, index) => isUndefined(index) ? [] : Array.isArray(index) ? removeAtIndexes(data, index) : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n\nfunction prepend(data, value) {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n\nfunction insert(data, index, value) {\n  return [...data.slice(0, index), ...(Array.isArray(value) ? value : [value || undefined]), ...data.slice(index)];\n}\n\nvar fillEmptyArray = value => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\n  if (isObject(value)) {\n    const object = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nvar fillBooleanArray = value => (Array.isArray(value) ? value : [value]).map(mapValueToBoolean).flat();\n\nconst mapIds = (values = [], keyName) => {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const value of values) {\n      if (!!value && keyName in value) {\n        console.warn(`📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\n        break;\n      }\n    }\n  }\n\n  return values.map(value => Object.assign({\n    [keyName]: generateId()\n  }, value));\n};\n\nconst useFieldArray = ({\n  control,\n  name,\n  keyName = 'id'\n}) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\n    }\n  }\n\n  const focusIndexRef = useRef(-1);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef\n  } = control || methods.control;\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = useRef([...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName) ? get(fieldArrayDefaultValuesRef.current, name, []) : get(shouldUnregister ? defaultValuesRef.current : shallowFieldsStateRef.current, name, []))]);\n  const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, fields);\n  const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), []);\n\n  const getCurrentFieldsValues = () => get(getValues(), name, getFieldArrayValue()).map((item, index) => Object.assign(Object.assign({}, getFieldArrayValue()[index]), item));\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\n  }\n\n  const setFieldAndValidState = fieldsValues => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      isMatchFieldArrayName(key, name) && removeFieldEventListener(fieldsRef.current[key], true);\n    }\n  };\n\n  const cleanup = ref => !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = updatedFieldArrayValues => {\n    const defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\n\n    const updateDirtyFieldsBaseOnDefaultValues = (base, target) => {\n      for (const key in base) {\n        for (const innerKey in base[key]) {\n          if (innerKey !== keyName && (!target[key] || !base[key] || base[key][innerKey] !== target[key][innerKey])) {\n            set(formStateRef.current.dirtyFields, `${name}[${key}]`, Object.assign(Object.assign({}, get(formStateRef.current.dirtyFields, `${name}[${key}]`, {})), {\n              [innerKey]: true\n            }));\n          }\n        }\n      }\n    };\n\n    if (updatedFieldArrayValues) {\n      updateDirtyFieldsBaseOnDefaultValues(defaultFieldArrayValues, updatedFieldArrayValues);\n      updateDirtyFieldsBaseOnDefaultValues(updatedFieldArrayValues, defaultFieldArrayValues);\n    }\n  };\n\n  const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (readFormStateRef.current.touched && get(formStateRef.current.touched, name)) {\n      const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      const output = method(get(formStateRef.current.dirtyFields, name, []), args.argC, args.argD);\n      shouldSet && set(formStateRef.current.dirtyFields, name, output);\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (shouldUpdateValid && readFormStateRef.current.isValid && !validateResolver) {\n      set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\n      cleanup(validFieldsRef.current);\n      set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields: formStateRef.current.dirtyFields,\n      isDirty: isFormDirty(name, updatedFormValues.map((_a = {}) => {\n        var _b = keyName,\n            omitted = _a[_b],\n            rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n        return rest;\n      })),\n      touched: formStateRef.current.touched\n    });\n  };\n\n  const append = (value, shouldFocus = true) => {\n    const updateFormValues = [...getFieldArrayValue(), ...mapIds(Array.isArray(value) ? value : [value], keyName)];\n    setFieldAndValidState(updateFormValues);\n\n    if (readFormStateRef.current.dirtyFields || readFormStateRef.current.isDirty) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields\n      });\n    }\n\n    !shouldUnregister && set(shallowFieldsStateRef.current, name, [...(get(shallowFieldsStateRef.current, name) || []), value]);\n    focusIndexRef.current = shouldFocus ? fields.length : -1;\n  };\n\n  const prepend$1 = (value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(prepend, {\n      argA: emptyArray,\n      argC: fillBooleanArray(value)\n    }, updatedFieldArrayValues);\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = index => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues = removeArrayAt(fieldValues, index);\n    setFieldAndValidState(updatedFieldValues);\n    resetFields();\n    batchStateUpdate(removeArrayAt, {\n      argA: index,\n      argC: index\n    }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\n  };\n\n  const insert$1 = (index, value, shouldFocus = true) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(insert, {\n      argA: index,\n      argB: emptyArray,\n      argC: index,\n      argD: fillBooleanArray(value)\n    }, updatedFieldArrayValues, insert(fieldValues, index));\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA, indexB) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(swapArrayAt, {\n      argA: indexA,\n      argB: indexB,\n      argC: indexA,\n      argD: indexB\n    }, undefined, fieldValues, false);\n  };\n\n  const move = (from, to) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(moveArrayAt, {\n      argA: from,\n      argB: to,\n      argC: from,\n      argD: to\n    }, undefined, fieldValues, false);\n  };\n\n  const reset = data => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn('📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n\n        if (key.startsWith(`${name}[${focusIndexRef.current}]`) && field.ref.focus) {\n          field.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n  useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n  return {\n    swap: useCallback(swap, [name]),\n    move: useCallback(move, [name]),\n    prepend: useCallback(prepend$1, [name]),\n    append: useCallback(append, [name]),\n    remove: useCallback(remove, [name]),\n    insert: useCallback(insert$1, [name]),\n    fields\n  };\n};\n\nfunction useWatch({\n  control,\n  name,\n  defaultValue\n}) {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef\n  } = control || methods.control;\n  const [value, setValue] = useState(isUndefined(defaultValue) ? isString(name) ? get(defaultValuesRef.current, name) : Array.isArray(name) ? name.reduce((previous, inputName) => Object.assign(Object.assign({}, previous), {\n    [inputName]: get(defaultValuesRef.current, inputName)\n  }), {}) : defaultValuesRef.current : defaultValue);\n  const idRef = useRef();\n  const defaultValueRef = useRef(defaultValue);\n  const updateWatchValue = useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(isObject(value) ? Object.assign({}, value) : Array.isArray(value) ? [...value] : value);\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn('📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\n      }\n    }\n\n    const id = idRef.current = generateId();\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [name, updateWatchValue, useWatchRenderFunctionsRef, useWatchFieldsRef, watchInternal, defaultValueRef]);\n  return isUndefined(value) ? defaultValue : value;\n}\n\nvar getInputValue = event => isPrimitive(event) || !isObject(event.target) || isObject(event.target) && !event.type ? event : isUndefined(event.target.value) ? event.target.checked : event.target.value;\n\nconst Controller = _a => {\n  var {\n    name,\n    rules,\n    as,\n    render,\n    defaultValue,\n    control,\n    onFocus\n  } = _a,\n      rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\n\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error('📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: {\n      isReValidateOnBlur,\n      isReValidateOnChange\n    },\n    formStateRef: {\n      current: {\n        isSubmitted,\n        touched\n      }\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n\n  const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray ? get(shallowFieldsStateRef.current, name) : isUndefined(defaultValue) ? get(defaultValuesRef.current, name) : defaultValue;\n\n  const [value, setInputStateValue] = useState(getInitialValue());\n  const valueRef = useRef(value);\n  const ref = useRef({\n    focus: () => null\n  });\n  const onFocusRef = useRef(onFocus || (() => ref.current.focus()));\n  const shouldValidate = useCallback(isBlurEvent => !skipValidation(Object.assign({\n    isBlurEvent,\n    isReValidateOnBlur,\n    isReValidateOnChange,\n    isSubmitted,\n    isTouched: !!get(touched, name)\n  }, mode)), [isReValidateOnBlur, isReValidateOnChange, isSubmitted, touched, name, mode]);\n  const commonTask = useCallback(([event]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n  const registerField = useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn('📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller');\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = Object.assign({\n        ref: fieldsRef.current[name].ref\n      }, rules);\n    } else {\n      register(Object.defineProperty({\n        name,\n        focus: onFocusRef.current\n      }, VALUE, {\n        set(data) {\n          setInputStateValue(data);\n          valueRef.current = data;\n        },\n\n        get() {\n          return valueRef.current;\n        }\n\n      }), rules);\n\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n  useEffect(() => () => unregister(name), [unregister, name]);\n  useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(`📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\n      }\n\n      if (!as && !render || as && render) {\n        console.warn(`📋 ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`);\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n  useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n  const onBlur = useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  }, [name, touched, updateFormState, shouldValidate, trigger, readFormStateRef]);\n  const onChange = useCallback((...event) => setValue(name, commonTask(event), {\n    shouldValidate: shouldValidate(),\n    shouldDirty: true\n  }), [setValue, commonTask, name, shouldValidate]);\n  const commonProps = {\n    onChange,\n    onBlur,\n    name,\n    value,\n    ref\n  };\n  const props = Object.assign(Object.assign({}, rest), commonProps);\n  return as ? isValidElement(as) ? cloneElement(as, props) : createElement(as, props) : render ? render(commonProps) : null;\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };","map":{"version":3,"sources":["../src/utils/isHTMLElement.ts","../src/constants.ts","../src/logic/attachEventListeners.ts","../src/utils/isNullOrUndefined.ts","../src/utils/isObject.ts","../src/utils/isKey.ts","../src/utils/compact.ts","../src/utils/stringToPath.ts","../src/utils/set.ts","../src/logic/transformToNestObject.ts","../src/utils/isUndefined.ts","../src/utils/get.ts","../src/logic/focusOnErrorField.ts","../src/logic/removeAllEventListeners.ts","../src/logic/getRadioValue.ts","../src/logic/getMultipleSelectValue.ts","../src/utils/isRadioInput.ts","../src/utils/isFileInput.ts","../src/utils/isCheckBoxInput.ts","../src/utils/isMultipleSelect.ts","../src/logic/getCheckboxValue.ts","../src/logic/getFieldValue.ts","../src/utils/isDetached.ts","../src/utils/isEmptyObject.ts","../src/utils/isBoolean.ts","../src/utils/unset.ts","../src/logic/findRemovedFieldAndRemoveListener.ts","../src/logic/setFieldArrayDirtyFields.ts","../src/utils/isString.ts","../src/utils/isPrimitive.ts","../src/utils/deepMerge.ts","../src/logic/getFieldsValues.ts","../src/utils/deepEqual.ts","../src/logic/isErrorStateChanged.ts","../src/utils/isRegex.ts","../src/logic/getValueAndMessage.ts","../src/utils/isFunction.ts","../src/utils/isMessage.ts","../src/logic/getValidateError.ts","../src/logic/appendErrors.ts","../src/logic/validateField.ts","../src/utils/getPath.ts","../src/logic/assignWatchFields.ts","../src/logic/skipValidation.ts","../src/logic/getFieldArrayParentName.ts","../src/logic/isNameInFieldArray.ts","../src/utils/isSelectInput.ts","../src/utils/onDomRemove.ts","../src/utils/cloneObject.ts","../src/utils/validationModeChecker.ts","../src/utils/isRadioOrCheckbox.ts","../src/useForm.ts","../src/useFormContext.tsx","../src/logic/generateId.ts","../src/utils/remove.ts","../src/utils/move.ts","../src/utils/swap.ts","../src/utils/prepend.ts","../src/utils/insert.ts","../src/utils/fillEmptyArray.ts","../src/utils/fillBooleanArray.ts","../src/useFieldArray.ts","../src/useWatch.ts","../src/logic/getInputValue.ts","../src/controller.tsx"],"names":["isCheckBox","getFieldsValue","React.useRef","React.useState","React.useCallback","React.useEffect","React.useMemo","React.createContext","React.useContext","React.createElement","prepend","prependAt","insert","insertAt","React.isValidElement","React.cloneElement"],"mappings":"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","sourcesContent":["export default (value: any): value is HTMLElement =>\n  value instanceof HTMLElement;\n","import { ValidationMode } from './types';\n\nexport const EVENTS = {\n  BLUR: 'blur',\n  CHANGE: 'change',\n  INPUT: 'input',\n};\n\nexport const VALIDATION_MODE: ValidationMode = {\n  onBlur: 'onBlur',\n  onChange: 'onChange',\n  onSubmit: 'onSubmit',\n  onTouched: 'onTouched',\n  all: 'all',\n};\n\nexport const VALUE = 'value';\n\nexport const SELECT = 'select';\n\nexport const UNDEFINED = 'undefined';\n\nexport const INPUT_VALIDATION_RULES = {\n  max: 'max',\n  min: 'min',\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  pattern: 'pattern',\n  required: 'required',\n  validate: 'validate',\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Field } from '../types';\n\nexport default function attachEventListeners(\n  { ref }: Field,\n  shouldAttachChangeEvent?: boolean,\n  handleChange?: EventListenerOrEventListenerObject,\n): void {\n  if (isHTMLElement(ref) && handleChange) {\n    ref.addEventListener(\n      shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT,\n      handleChange,\n    );\n    ref.addEventListener(EVENTS.BLUR, handleChange);\n  }\n}\n","export default (value: unknown): value is null | undefined => value == null;\n","import isNullOrUndefined from './isNullOrUndefined';\n\nexport const isObjectType = (value: unknown) => typeof value === 'object';\n\nexport default <T extends object>(value: unknown): value is T =>\n  !isNullOrUndefined(value) &&\n  !Array.isArray(value) &&\n  isObjectType(value) &&\n  !(value instanceof Date);\n","export default (value: [] | string) =>\n  !Array.isArray(value) &&\n  (/^\\w*$/.test(value) ||\n    !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n","export default (value: any[]) => value.filter(Boolean);\n","import compact from './compact';\n\nexport default (input: string): string[] =>\n  compact(\n    input\n      .replace(/[\"|']/g, '')\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      .split('.'),\n  );\n","import isObject from './isObject';\nimport isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport { FieldValues } from '../types';\n\nexport default function set(\n  object: FieldValues,\n  path: string,\n  value?: unknown,\n) {\n  let index = -1;\n  const tempPath = isKey(path) ? [path] : stringToPath(path);\n  const length = tempPath.length;\n  const lastIndex = length - 1;\n\n  while (++index < length) {\n    const key = tempPath[index];\n    let newValue = value;\n\n    if (index !== lastIndex) {\n      const objValue = object[key];\n      newValue =\n        isObject(objValue) || Array.isArray(objValue)\n          ? objValue\n          : !isNaN(+tempPath[index + 1])\n          ? []\n          : {};\n    }\n    object[key] = newValue;\n    object = object[key];\n  }\n  return object;\n}\n","import set from '../utils/set';\nimport isKey from '../utils/isKey';\nimport { FieldValues } from '../types';\n\nexport default (data: FieldValues, value: Record<string, any> = {}): any => {\n  for (const key in data) {\n    !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\n  }\n  return value;\n};\n","export default (val: unknown): val is undefined => val === undefined;\n","import isUndefined from './isUndefined';\nimport isNullOrUndefined from './isNullOrUndefined';\nimport compact from './compact';\n\nexport default (obj: any, path: string, defaultValue?: unknown) => {\n  const result = compact(path.split(/[,[\\].]+?/)).reduce(\n    (result, key) => (isNullOrUndefined(result) ? result : result[key]),\n    obj,\n  );\n\n  return isUndefined(result) || result === obj\n    ? isUndefined(obj[path])\n      ? defaultValue\n      : obj[path]\n    : result;\n};\n","import get from '../utils/get';\nimport { FieldErrors, FieldRefs } from '../types';\nimport isUndefined from '../utils/isUndefined';\n\nexport default <TFieldValues>(\n  fields: FieldRefs<TFieldValues>,\n  fieldErrors: FieldErrors<TFieldValues>,\n) => {\n  for (const key in fields) {\n    if (get(fieldErrors, key)) {\n      const field = fields[key];\n\n      if (field) {\n        if (field.ref.focus) {\n          if (isUndefined(field.ref.focus())) {\n            break;\n          }\n        } else if (field.options) {\n          field.options[0].ref.focus();\n\n          break;\n        }\n      }\n    }\n  }\n};\n","import isHTMLElement from '../utils/isHTMLElement';\nimport { EVENTS } from '../constants';\nimport { Ref } from '../types';\n\nexport default (\n  ref: Ref,\n  validateWithStateUpdate: EventListenerOrEventListenerObject,\n): void => {\n  if (isHTMLElement(ref) && ref.removeEventListener) {\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\n  }\n};\n","import { RadioOrCheckboxOption } from '../types';\n\ntype RadioFieldResult = {\n  isValid: boolean;\n  value: number | string;\n};\n\nconst defaultReturn: RadioFieldResult = {\n  isValid: false,\n  value: '',\n};\n\nexport default (options?: RadioOrCheckboxOption[]): RadioFieldResult =>\n  Array.isArray(options)\n    ? options.reduce(\n        (previous, option): RadioFieldResult =>\n          option && option.ref.checked\n            ? {\n                isValid: true,\n                value: option.ref.value,\n              }\n            : previous,\n        defaultReturn,\n      )\n    : defaultReturn;\n","export default (\n  options: HTMLOptionElement[] | HTMLOptionsCollection,\n): string[] =>\n  [...options]\n    .filter(({ selected }): boolean => selected)\n    .map(({ value }): string => value);\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'radio';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'file';\n","import { FieldElement } from '../types';\n\nexport default (element: FieldElement): element is HTMLInputElement =>\n  element.type === 'checkbox';\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-multiple`;\n","import isUndefined from '../utils/isUndefined';\nimport { RadioOrCheckboxOption } from '../types';\n\ntype CheckboxFieldResult = {\n  isValid: boolean;\n  value: string | string[] | boolean;\n};\n\nconst defaultResult: CheckboxFieldResult = {\n  value: false,\n  isValid: false,\n};\n\nconst validResult = { value: true, isValid: true };\n\nexport default (options?: RadioOrCheckboxOption[]): CheckboxFieldResult => {\n  if (Array.isArray(options)) {\n    if (options.length > 1) {\n      const values = options\n        .filter((option) => option && option.ref.checked)\n        .map(({ ref: { value } }) => value);\n      return { value: values, isValid: !!values.length };\n    }\n\n    const { checked, value, attributes } = options[0].ref;\n\n    return checked\n      ? attributes && !isUndefined((attributes as any).value)\n        ? isUndefined(value) || value === ''\n          ? validResult\n          : { value: value, isValid: true }\n        : validResult\n      : defaultResult;\n  }\n\n  return defaultResult;\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getMultipleSelectValue from './getMultipleSelectValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport get from '../utils/get';\nimport isFileInput from '../utils/isFileInput';\nimport isCheckBox from '../utils/isCheckBoxInput';\nimport isMultipleSelect from '../utils/isMultipleSelect';\nimport getCheckboxValue from './getCheckboxValue';\nimport { FieldRefs, FieldValues, InternalFieldName } from '../types';\n\nexport default function getFieldValue<TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  name: InternalFieldName<TFieldValues>,\n  shallowFieldsStateRef?: React.MutableRefObject<Partial<FieldValues>>,\n  excludeDisabled?: boolean,\n) {\n  const field = fieldsRef.current[name]!;\n\n  if (field) {\n    const {\n      ref: { value, disabled },\n      ref,\n    } = field;\n\n    if (disabled && excludeDisabled) {\n      return;\n    }\n\n    if (isFileInput(ref)) {\n      return ref.files;\n    }\n\n    if (isRadioInput(ref)) {\n      return getRadioValue(field.options).value;\n    }\n\n    if (isMultipleSelect(ref)) {\n      return getMultipleSelectValue(ref.options);\n    }\n\n    if (isCheckBox(ref)) {\n      return getCheckboxValue(field.options).value;\n    }\n\n    return value;\n  }\n\n  if (shallowFieldsStateRef) {\n    return get(shallowFieldsStateRef.current, name);\n  }\n}\n","import { Ref } from '../types';\n\nexport default function isDetached(element: Ref): boolean {\n  if (!element) {\n    return true;\n  }\n\n  if (\n    !(element instanceof HTMLElement) ||\n    element.nodeType === Node.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n\n  return isDetached(element.parentNode as Ref);\n}\n","import isObject from './isObject';\nimport { EmptyObject } from '../types';\n\nexport default (value: unknown): value is EmptyObject =>\n  isObject(value) && !Object.keys(value).length;\n","export default (value: unknown): value is boolean => typeof value === 'boolean';\n","import isKey from './isKey';\nimport stringToPath from './stringToPath';\nimport isEmptyObject from './isEmptyObject';\nimport isObject from './isObject';\nimport isUndefined from './isUndefined';\nimport isBoolean from './isBoolean';\n\nfunction baseGet(object: any, updatePath: (string | number)[]) {\n  const path = updatePath.slice(0, -1);\n  const length = path.length;\n  let index = 0;\n\n  while (index < length) {\n    object = isUndefined(object) ? index++ : object[updatePath[index++]];\n  }\n\n  return object;\n}\n\nexport default function unset(object: any, path: string) {\n  const updatePath = isKey(path) ? [path] : stringToPath(path);\n  const childObject =\n    updatePath.length == 1 ? object : baseGet(object, updatePath);\n  const key = updatePath[updatePath.length - 1];\n  let previousObjRef = undefined;\n\n  if (childObject) {\n    delete childObject[key];\n  }\n\n  for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\n    let index = -1;\n    let objectRef = undefined;\n    const currentPaths = updatePath.slice(0, -(k + 1));\n    const currentPathsLength = currentPaths.length - 1;\n\n    if (k > 0) {\n      previousObjRef = object;\n    }\n\n    while (++index < currentPaths.length) {\n      const item = currentPaths[index];\n      objectRef = objectRef ? objectRef[item] : object[item];\n\n      if (\n        currentPathsLength === index &&\n        ((isObject(objectRef) && isEmptyObject(objectRef)) ||\n          (Array.isArray(objectRef) &&\n            !objectRef.filter(\n              (data) =>\n                (isObject(data) && !isEmptyObject(data)) || isBoolean(data),\n            ).length))\n      ) {\n        previousObjRef ? delete previousObjRef[item] : delete object[item];\n      }\n\n      previousObjRef = objectRef;\n    }\n  }\n\n  return object;\n}\n","import * as React from 'react';\nimport removeAllEventListeners from './removeAllEventListeners';\nimport getFieldValue from './getFieldValue';\nimport isRadioInput from '../utils/isRadioInput';\nimport set from '../utils/set';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isDetached from '../utils/isDetached';\nimport unset from '../utils/unset';\nimport compact from '../utils/compact';\nimport isUndefined from '../utils/isUndefined';\nimport { Field, FieldRefs, FieldValues, Ref } from '../types';\n\nconst isSameRef = (fieldValue: Field, ref: Ref) =>\n  fieldValue && fieldValue.ref === ref;\n\nexport default function findRemovedFieldAndRemoveListener<\n  TFieldValues extends FieldValues\n>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  handleChange: ({ type, target }: Event) => Promise<void | boolean>,\n  field: Field,\n  shallowFieldsStateRef: React.MutableRefObject<FieldValues>,\n  shouldUnregister?: boolean,\n  forceDelete?: boolean,\n): void {\n  const {\n    ref,\n    ref: { name, type },\n  } = field;\n  const fieldRef = fieldsRef.current[name] as Field;\n\n  if (!shouldUnregister) {\n    const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n\n    if (!isUndefined(value)) {\n      set(shallowFieldsStateRef.current, name, value);\n    }\n  }\n\n  if (!type) {\n    delete fieldsRef.current[name];\n    return;\n  }\n\n  if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\n    const { options } = fieldRef;\n\n    if (Array.isArray(options) && options.length) {\n      compact(options).forEach((option, index): void => {\n        const { ref } = option;\n        if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\n          removeAllEventListeners(ref, handleChange);\n          unset(options, `[${index}]`);\n        }\n      });\n\n      if (options && !compact(options).length) {\n        delete fieldsRef.current[name];\n      }\n    } else {\n      delete fieldsRef.current[name];\n    }\n  } else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\n    removeAllEventListeners(ref, handleChange);\n\n    delete fieldsRef.current[name];\n  }\n}\n","import { get } from '../utils';\nimport set from '../utils/set';\n\nexport default function setFieldArrayDirtyFields<\n  T extends U,\n  U extends Record<string, unknown>[],\n  K extends Record<string, boolean | []>\n>(\n  values: T,\n  defaultValues: U,\n  dirtyFields: Record<string, boolean | []>[],\n  parentNode?: K,\n  parentName?: keyof K,\n) {\n  let index = -1;\n\n  while (++index < values.length) {\n    for (const key in values[index]) {\n      if (Array.isArray(values[index][key])) {\n        !dirtyFields[index] && (dirtyFields[index] = {});\n        dirtyFields[index][key] = [];\n        setFieldArrayDirtyFields(\n          values[index][key],\n          get(defaultValues[index] || {}, key, []),\n          dirtyFields[index][key] as [],\n          dirtyFields[index],\n          key,\n        );\n      } else {\n        get(defaultValues[index] || {}, key) === values[index][key]\n          ? set(dirtyFields[index] || {}, key)\n          : (dirtyFields[index] = {\n              ...dirtyFields[index],\n              [key]: true,\n            });\n      }\n    }\n    !dirtyFields.length &&\n      parentNode &&\n      delete parentNode[parentName as keyof K];\n  }\n\n  return dirtyFields.length ? dirtyFields : undefined;\n}\n","export default (value: unknown): value is string => typeof value === 'string';\n","import isNullOrUndefined from './isNullOrUndefined';\nimport { isObjectType } from './isObject';\nimport { Primitive } from '../types';\n\nexport default (value: unknown): value is Primitive =>\n  isNullOrUndefined(value) || !isObjectType(value);\n","import isObject from './isObject';\nimport isPrimitive from './isPrimitive';\n\nexport function deepMerge<\n  T extends Record<keyof T, any>,\n  U extends Record<keyof U, any>\n>(target: T, source: U): T & U {\n  if (isPrimitive(target) || isPrimitive(source)) {\n    return source;\n  }\n\n  for (const key in source) {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    try {\n      target[key] =\n        (isObject(targetValue) && isObject(sourceValue)) ||\n        (Array.isArray(targetValue) && Array.isArray(sourceValue))\n          ? deepMerge(targetValue, sourceValue)\n          : sourceValue;\n    } catch {}\n  }\n\n  return target;\n}\n","import * as React from 'react';\nimport getFieldValue from './getFieldValue';\nimport isString from '../utils/isString';\nimport { deepMerge } from '../utils/deepMerge';\nimport isUndefined from '../utils/isUndefined';\nimport { InternalFieldName, FieldValues, FieldRefs } from '../types';\nimport transformToNestObject from './transformToNestObject';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  shallowFieldsStateRef?: React.MutableRefObject<Record<string, any>>,\n  excludeDisabled?: boolean,\n  search?:\n    | InternalFieldName<TFieldValues>\n    | InternalFieldName<TFieldValues>[]\n    | { nest: boolean },\n) => {\n  const output = {} as TFieldValues;\n\n  for (const name in fieldsRef.current) {\n    if (\n      isUndefined(search) ||\n      (isString(search)\n        ? name.startsWith(search)\n        : Array.isArray(search) && search.find((data) => name.startsWith(data)))\n    ) {\n      output[name as InternalFieldName<TFieldValues>] = getFieldValue(\n        fieldsRef,\n        name,\n        undefined,\n        excludeDisabled,\n      );\n    }\n  }\n\n  return deepMerge(\n    transformToNestObject({ ...((shallowFieldsStateRef || {}).current || {}) }),\n    transformToNestObject(output),\n  );\n};\n","import isObject from '../utils/isObject';\nimport isPrimitive from './isPrimitive';\n\nexport default function deepEqual(\n  object1: any,\n  object2: any,\n  isErrorObject?: boolean,\n) {\n  if (isPrimitive(object1) || isPrimitive(object2)) {\n    return object1 === object2;\n  }\n\n  const keys1 = Object.keys(object1);\n  const keys2 = Object.keys(object2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (const key of keys1) {\n    if (!(isErrorObject && ['ref', 'context'].includes(key))) {\n      const val1 = object1[key];\n      const val2 = object2[key];\n\n      if (\n        (isObject(val1) || Array.isArray(val1)) &&\n        (isObject(val2) || Array.isArray(val2))\n          ? !deepEqual(val1, val2, isErrorObject)\n          : val1 !== val2\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import get from '../utils/get';\nimport isUndefined from '../utils/isUndefined';\nimport deepEqual from '../utils/deepEqual';\nimport {\n  FieldValues,\n  InternalFieldName,\n  FieldErrors,\n  FieldNamesMarkedBoolean,\n  FieldError,\n} from '../types';\n\nexport default function isErrorStateChanged<TFieldValues extends FieldValues>({\n  errors,\n  name,\n  error,\n  validFields,\n  fieldsWithValidation,\n}: {\n  errors: FieldErrors<TFieldValues>;\n  error: FieldError | undefined;\n  name: InternalFieldName<TFieldValues>;\n  validFields: FieldNamesMarkedBoolean<TFieldValues>;\n  fieldsWithValidation: FieldNamesMarkedBoolean<TFieldValues>;\n}): boolean {\n  const isValid = isUndefined(error);\n  const previousError = get(errors, name);\n\n  return (\n    (isValid && !!previousError) ||\n    (!isValid && !deepEqual(previousError, error, true)) ||\n    (isValid && get(fieldsWithValidation, name) && !get(validFields, name))\n  );\n}\n","export default (value: unknown): value is RegExp => value instanceof RegExp;\n","import isObject from '../utils/isObject';\nimport isRegex from '../utils/isRegex';\nimport { ValidationRule, ValidationValueMessage } from '../types';\n\nconst isValueMessage = (\n  value?: ValidationRule,\n): value is ValidationValueMessage => isObject(value) && !isRegex(value);\n\nexport default (validationData?: ValidationRule) =>\n  isValueMessage(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n      };\n","export default (value: unknown): value is Function =>\n  typeof value === 'function';\n","import { isValidElement } from 'react';\nimport isString from '../utils/isString';\nimport isObject from '../utils/isObject';\nimport { Message } from '../types';\n\nexport default (value: unknown): value is Message =>\n  isString(value) || (isObject(value) && isValidElement(value));\n","import isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport { FieldError, ValidateResult, Ref } from '../types';\n\nexport default function getValidateError(\n  result: ValidateResult,\n  ref: Ref,\n  type = 'validate',\n): FieldError | void {\n  if (isMessage(result) || (isBoolean(result) && !result)) {\n    return {\n      type,\n      message: isMessage(result) ? result : '',\n      ref,\n    };\n  }\n}\n","import {\n  InternalFieldName,\n  ValidateResult,\n  InternalFieldErrors,\n} from '../types';\n\nexport default <TFieldValues>(\n  name: InternalFieldName<TFieldValues>,\n  validateAllFieldCriteria: boolean,\n  errors: InternalFieldErrors<TFieldValues>,\n  type: string,\n  message: ValidateResult,\n) => {\n  if (validateAllFieldCriteria) {\n    const error = errors[name];\n\n    return {\n      ...error,\n      types: {\n        ...(error && error.types ? error.types : {}),\n        [type]: message || true,\n      },\n    };\n  }\n\n  return {};\n};\n","import * as React from 'react';\nimport getRadioValue from './getRadioValue';\nimport getCheckboxValue from './getCheckboxValue';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isRadioInput from '../utils/isRadioInput';\nimport getValueAndMessage from './getValueAndMessage';\nimport isCheckBoxInput from '../utils/isCheckBoxInput';\nimport isString from '../utils/isString';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isObject from '../utils/isObject';\nimport isFunction from '../utils/isFunction';\nimport getFieldsValue from './getFieldValue';\nimport isRegex from '../utils/isRegex';\nimport isBoolean from '../utils/isBoolean';\nimport isMessage from '../utils/isMessage';\nimport getValidateError from './getValidateError';\nimport appendErrors from './appendErrors';\nimport { INPUT_VALIDATION_RULES } from '../constants';\nimport {\n  Field,\n  FieldValues,\n  FieldRefs,\n  Message,\n  FieldError,\n  InternalFieldName,\n  InternalFieldErrors,\n} from '../types';\n\nexport default async <TFieldValues extends FieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  validateAllFieldCriteria: boolean,\n  {\n    ref,\n    ref: { type, value },\n    options,\n    required,\n    maxLength,\n    minLength,\n    min,\n    max,\n    pattern,\n    validate,\n  }: Field,\n  shallowFieldsStateRef: React.MutableRefObject<Record<string, any>>,\n): Promise<InternalFieldErrors<TFieldValues>> => {\n  const fields = fieldsRef.current;\n  const name: InternalFieldName<TFieldValues> = ref.name;\n  const error: InternalFieldErrors<TFieldValues> = {};\n  const isRadio = isRadioInput(ref);\n  const isCheckBox = isCheckBoxInput(ref);\n  const isRadioOrCheckbox = isRadio || isCheckBox;\n  const isEmpty = value === '';\n  const appendErrorsCurry = appendErrors.bind(\n    null,\n    name,\n    validateAllFieldCriteria,\n    error,\n  );\n  const getMinMaxMessage = (\n    exceedMax: boolean,\n    maxLengthMessage: Message,\n    minLengthMessage: Message,\n    maxType = INPUT_VALIDATION_RULES.maxLength,\n    minType = INPUT_VALIDATION_RULES.minLength,\n  ) => {\n    const message = exceedMax ? maxLengthMessage : minLengthMessage;\n    error[name] = {\n      type: exceedMax ? maxType : minType,\n      message,\n      ref,\n      ...(exceedMax\n        ? appendErrorsCurry(maxType, message)\n        : appendErrorsCurry(minType, message)),\n    };\n  };\n\n  if (\n    required &&\n    ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\n      (isBoolean(value) && !value) ||\n      (isCheckBox && !getCheckboxValue(options).isValid) ||\n      (isRadio && !getRadioValue(options).isValid))\n  ) {\n    const { value: requiredValue, message: requiredMessage } = isMessage(\n      required,\n    )\n      ? { value: !!required, message: required }\n      : getValueAndMessage(required);\n\n    if (requiredValue) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.required,\n        message: requiredMessage,\n        ref: isRadioOrCheckbox\n          ? (((fields[name] as Field).options || [])[0] || {}).ref\n          : ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\n    let exceedMax;\n    let exceedMin;\n    const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\n    const { value: minValue, message: minMessage } = getValueAndMessage(min);\n\n    if (type === 'number' || (!type && !isNaN(value))) {\n      const valueNumber =\n        (ref as HTMLInputElement).valueAsNumber || parseFloat(value);\n      if (!isNullOrUndefined(maxValue)) {\n        exceedMax = valueNumber > maxValue;\n      }\n      if (!isNullOrUndefined(minValue)) {\n        exceedMin = valueNumber < minValue;\n      }\n    } else {\n      const valueDate =\n        (ref as HTMLInputElement).valueAsDate || new Date(value);\n      if (isString(maxValue)) {\n        exceedMax = valueDate > new Date(maxValue);\n      }\n      if (isString(minValue)) {\n        exceedMin = valueDate < new Date(minValue);\n      }\n    }\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(\n        !!exceedMax,\n        maxMessage,\n        minMessage,\n        INPUT_VALIDATION_RULES.max,\n        INPUT_VALIDATION_RULES.min,\n      );\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (isString(value) && !isEmpty && (maxLength || minLength)) {\n    const {\n      value: maxLengthValue,\n      message: maxLengthMessage,\n    } = getValueAndMessage(maxLength);\n    const {\n      value: minLengthValue,\n      message: minLengthMessage,\n    } = getValueAndMessage(minLength);\n    const inputLength = value.toString().length;\n    const exceedMax =\n      !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\n    const exceedMin =\n      !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\n\n    if (exceedMax || exceedMin) {\n      getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (pattern && !isEmpty) {\n    const { value: patternValue, message: patternMessage } = getValueAndMessage(\n      pattern,\n    );\n\n    if (isRegex(patternValue) && !patternValue.test(value)) {\n      error[name] = {\n        type: INPUT_VALIDATION_RULES.pattern,\n        message: patternMessage,\n        ref,\n        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage),\n      };\n      if (!validateAllFieldCriteria) {\n        return error;\n      }\n    }\n  }\n\n  if (validate) {\n    const fieldValue = getFieldsValue(fieldsRef, name, shallowFieldsStateRef);\n    const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\n\n    if (isFunction(validate)) {\n      const result = await validate(fieldValue);\n      const validateError = getValidateError(result, validateRef);\n\n      if (validateError) {\n        error[name] = {\n          ...validateError,\n          ...appendErrorsCurry(\n            INPUT_VALIDATION_RULES.validate,\n            validateError.message,\n          ),\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    } else if (isObject(validate)) {\n      let validationResult = {} as FieldError;\n      for (const [key, validateFunction] of Object.entries(validate)) {\n        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n          break;\n        }\n\n        const validateResult = await validateFunction(fieldValue);\n        const validateError = getValidateError(\n          validateResult,\n          validateRef,\n          key,\n        );\n\n        if (validateError) {\n          validationResult = {\n            ...validateError,\n            ...appendErrorsCurry(key, validateError.message),\n          };\n\n          if (validateAllFieldCriteria) {\n            error[name] = validationResult;\n          }\n        }\n      }\n\n      if (!isEmptyObject(validationResult)) {\n        error[name] = {\n          ref: validateRef,\n          ...validationResult,\n        };\n        if (!validateAllFieldCriteria) {\n          return error;\n        }\n      }\n    }\n  }\n\n  return error;\n};\n","import isPrimitive from './isPrimitive';\nimport isObject from './isObject';\n\nexport const getPath = <T extends string, U extends object | unknown[]>(\n  path: T,\n  values: U,\n): string[] => {\n  const getInnerPath = <K>(key: K, value: U, isObject?: boolean) => {\n    const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\n    return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\n  };\n\n  return Object.entries(values)\n    .map(([key, value]) => getInnerPath(key, value, isObject(values)))\n    .flat(Infinity) as string[];\n};\n","import get from '../utils/get';\nimport { getPath } from '../utils/getPath';\nimport isEmptyObject from '../utils/isEmptyObject';\nimport isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport {\n  DeepPartial,\n  FieldValue,\n  FieldValues,\n  InternalFieldName,\n  UnpackNestedValue,\n} from '../types';\n\nexport default <TFieldValues extends FieldValues>(\n  fieldValues: TFieldValues,\n  fieldName: InternalFieldName<TFieldValues>,\n  watchFields: Set<InternalFieldName<TFieldValues>>,\n  inputValue: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  isSingleField?: boolean,\n):\n  | FieldValue<TFieldValues>\n  | UnpackNestedValue<DeepPartial<TFieldValues>>\n  | undefined => {\n  let value;\n\n  watchFields.add(fieldName);\n\n  if (isEmptyObject(fieldValues)) {\n    value = undefined;\n  } else {\n    value = get(fieldValues, fieldName);\n\n    if (isObject(value) || Array.isArray(value)) {\n      getPath(fieldName, value).forEach((name) => watchFields.add(name));\n    }\n  }\n\n  return isUndefined(value)\n    ? isSingleField\n      ? inputValue\n      : get(inputValue, fieldName)\n    : value;\n};\n","export default ({\n  isOnBlur,\n  isOnChange,\n  isOnTouch,\n  isTouched,\n  isReValidateOnBlur,\n  isReValidateOnChange,\n  isBlurEvent,\n  isSubmitted,\n  isOnAll,\n}: {\n  isOnAll?: boolean;\n  isOnBlur?: boolean;\n  isOnChange?: boolean;\n  isReValidateOnBlur?: boolean;\n  isReValidateOnChange?: boolean;\n  isBlurEvent?: boolean;\n  isSubmitted?: boolean;\n  isOnTouch?: boolean;\n  isTouched?: boolean;\n}) => {\n  if (isOnAll) {\n    return false;\n  } else if (!isSubmitted && isOnTouch) {\n    return !(isTouched || isBlurEvent);\n  } else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\n    return !isBlurEvent;\n  } else if (isSubmitted ? isReValidateOnChange : isOnChange) {\n    return isBlurEvent;\n  }\n  return true;\n};\n","export default (name: string) => name.substring(0, name.indexOf('['));\n","import { FieldValues, InternalFieldName } from '../types';\n\nexport const isMatchFieldArrayName = (name: string, searchName: string) =>\n  RegExp(\n    `^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]'),\n  ).test(name);\n\nexport default (\n  names: Set<InternalFieldName<FieldValues>>,\n  name: InternalFieldName<FieldValues>,\n) => [...names].some((current) => isMatchFieldArrayName(name, current));\n","import { FieldElement } from '../types';\nimport { SELECT } from '../constants';\n\nexport default (element: FieldElement): element is HTMLSelectElement =>\n  element.type === `${SELECT}-one`;\n","import * as React from 'react';\nimport { Field, FieldRefs } from '../types';\nimport isDetached from './isDetached';\n\nexport default function onDomRemove<TFieldValues>(\n  fieldsRef: React.MutableRefObject<FieldRefs<TFieldValues>>,\n  removeFieldEventListenerAndRef: (\n    field: Field | undefined,\n    forceDelete?: boolean,\n  ) => void,\n): MutationObserver {\n  const observer = new MutationObserver((): void => {\n    for (const field of Object.values(fieldsRef.current)) {\n      if (field && field.options) {\n        for (const option of field.options) {\n          if (option && option.ref && isDetached(option.ref)) {\n            removeFieldEventListenerAndRef(field);\n          }\n        }\n      } else if (field && isDetached(field.ref)) {\n        removeFieldEventListenerAndRef(field);\n      }\n    }\n  });\n\n  observer.observe(window.document, {\n    childList: true,\n    subtree: true,\n  });\n\n  return observer;\n}\n","import isPrimitive from './isPrimitive';\n\nexport default function cloneObject<T extends unknown>(\n  data: T,\n  isWeb: boolean,\n): T {\n  let copy: any;\n\n  if (isPrimitive(data) || (isWeb && data instanceof File)) {\n    return data;\n  }\n\n  if (data instanceof Date) {\n    copy = new Date(data.getTime());\n    return copy;\n  }\n\n  if (data instanceof Set) {\n    copy = new Set();\n    for (const item of data) {\n      copy.add(item);\n    }\n    return copy;\n  }\n\n  if (data instanceof Map) {\n    copy = new Map();\n    for (const key of data.keys()) {\n      copy.set(key, cloneObject(data.get(key), isWeb));\n    }\n    return copy;\n  }\n\n  copy = Array.isArray(data) ? [] : {};\n\n  for (const key in data) {\n    copy[key] = cloneObject(data[key], isWeb);\n  }\n\n  return copy;\n}\n","import { VALIDATION_MODE } from '../constants';\nimport { Mode } from '../types';\n\nexport default (\n  mode?: Mode,\n): {\n  isOnSubmit: boolean;\n  isOnBlur: boolean;\n  isOnChange: boolean;\n  isOnAll: boolean;\n  isOnTouch: boolean;\n} => ({\n  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n  isOnBlur: mode === VALIDATION_MODE.onBlur,\n  isOnChange: mode === VALIDATION_MODE.onChange,\n  isOnAll: mode === VALIDATION_MODE.all,\n  isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n","import isRadioInput from './isRadioInput';\nimport isCheckBoxInput from './isCheckBoxInput';\nimport { FieldElement } from '../types';\n\nexport default (ref: FieldElement): ref is HTMLInputElement =>\n  isRadioInput(ref) || isCheckBoxInput(ref);\n","import * as React from 'react';\nimport attachEventListeners from './logic/attachEventListeners';\nimport transformToNestObject from './logic/transformToNestObject';\nimport focusOnErrorField from './logic/focusOnErrorField';\nimport findRemovedFieldAndRemoveListener from './logic/findRemovedFieldAndRemoveListener';\nimport setFieldArrayDirtyFields from './logic/setFieldArrayDirtyFields';\nimport getFieldsValues from './logic/getFieldsValues';\nimport getFieldValue from './logic/getFieldValue';\nimport isErrorStateChanged from './logic/isErrorStateChanged';\nimport validateField from './logic/validateField';\nimport assignWatchFields from './logic/assignWatchFields';\nimport skipValidation from './logic/skipValidation';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport deepEqual from './utils/deepEqual';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport isCheckBoxInput from './utils/isCheckBoxInput';\nimport isEmptyObject from './utils/isEmptyObject';\nimport isRadioInput from './utils/isRadioInput';\nimport isSelectInput from './utils/isSelectInput';\nimport isFileInput from './utils/isFileInput';\nimport onDomRemove from './utils/onDomRemove';\nimport isObject from './utils/isObject';\nimport { getPath } from './utils/getPath';\nimport isPrimitive from './utils/isPrimitive';\nimport isFunction from './utils/isFunction';\nimport isString from './utils/isString';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport unset from './utils/unset';\nimport isKey from './utils/isKey';\nimport cloneObject from './utils/cloneObject';\nimport modeChecker from './utils/validationModeChecker';\nimport isMultipleSelect from './utils/isMultipleSelect';\nimport compact from './utils/compact';\nimport isNullOrUndefined from './utils/isNullOrUndefined';\nimport isRadioOrCheckboxFunction from './utils/isRadioOrCheckbox';\nimport isHTMLElement from './utils/isHTMLElement';\nimport { EVENTS, UNDEFINED, VALIDATION_MODE } from './constants';\nimport {\n  UseFormMethods,\n  FieldValues,\n  UnpackNestedValue,\n  FieldName,\n  InternalFieldName,\n  FieldValue,\n  FieldErrors,\n  Field,\n  FieldRefs,\n  UseFormOptions,\n  ValidationRules,\n  SubmitHandler,\n  FieldElement,\n  FormStateProxy,\n  ReadFormState,\n  Ref,\n  HandleChange,\n  RadioOrCheckboxOption,\n  OmitResetState,\n  NestedValue,\n  SetValueConfig,\n  ErrorOption,\n  FormState,\n  SubmitErrorHandler,\n  FieldNamesMarkedBoolean,\n  LiteralToPrimitive,\n  DeepPartial,\n  InternalNameSet,\n  DefaultValues,\n  FieldError,\n} from './types';\n\nconst isWindowUndefined = typeof window === UNDEFINED;\nconst isWeb =\n  typeof document !== UNDEFINED &&\n  !isWindowUndefined &&\n  !isUndefined(window.HTMLElement);\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\n\nexport function useForm<\n  TFieldValues extends FieldValues = FieldValues,\n  TContext extends object = object\n>({\n  mode = VALIDATION_MODE.onSubmit,\n  reValidateMode = VALIDATION_MODE.onChange,\n  resolver,\n  context,\n  defaultValues = {} as UnpackNestedValue<DeepPartial<TFieldValues>>,\n  shouldFocusError = true,\n  shouldUnregister = true,\n  criteriaMode,\n}: UseFormOptions<TFieldValues, TContext> = {}): UseFormMethods<TFieldValues> {\n  const fieldsRef = React.useRef<FieldRefs<TFieldValues>>({});\n  const fieldArrayDefaultValuesRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, unknown[]>\n  >({});\n  const fieldArrayValuesRef = React.useRef<\n    Record<InternalFieldName<FieldValues>, unknown[]>\n  >({});\n  const watchFieldsRef = React.useRef<InternalNameSet<TFieldValues>>(new Set());\n  const useWatchFieldsRef = React.useRef<\n    Record<string, InternalNameSet<TFieldValues>>\n  >({});\n  const useWatchRenderFunctionsRef = React.useRef<Record<string, () => void>>(\n    {},\n  );\n  const fieldsWithValidationRef = React.useRef<\n    FieldNamesMarkedBoolean<TFieldValues>\n  >({});\n  const validFieldsRef = React.useRef<FieldNamesMarkedBoolean<TFieldValues>>(\n    {},\n  );\n  const defaultValuesRef = React.useRef<DefaultValues<TFieldValues>>(\n    defaultValues,\n  );\n  const defaultValuesAtRenderRef = React.useRef<\n    Partial<DefaultValues<TFieldValues>>\n  >({});\n  const isUnMount = React.useRef(false);\n  const isWatchAllRef = React.useRef(false);\n  const handleChangeRef = React.useRef<HandleChange>();\n  const shallowFieldsStateRef = React.useRef(\n    shouldUnregister ? {} : cloneObject(defaultValues, isWeb),\n  );\n  const resetFieldArrayFunctionRef = React.useRef<\n    Record<\n      InternalFieldName<FieldValues>,\n      (data?: UnpackNestedValue<DeepPartial<TFieldValues>>) => void\n    >\n  >({});\n  const contextRef = React.useRef(context);\n  const resolverRef = React.useRef(resolver);\n  const fieldArrayNamesRef = React.useRef<InternalNameSet<TFieldValues>>(\n    new Set(),\n  );\n  const modeRef = React.useRef(modeChecker(mode));\n  const { isOnSubmit, isOnTouch } = modeRef.current;\n  const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\n  const [formState, setFormState] = React.useState<FormState<TFieldValues>>({\n    isDirty: false,\n    dirtyFields: {},\n    isSubmitted: false,\n    submitCount: 0,\n    touched: {},\n    isSubmitting: false,\n    isSubmitSuccessful: false,\n    isValid: !isOnSubmit,\n    errors: {},\n  });\n  const readFormStateRef = React.useRef<ReadFormState>({\n    isDirty: !isProxyEnabled,\n    dirtyFields: !isProxyEnabled,\n    touched: !isProxyEnabled || isOnTouch,\n    isSubmitting: !isProxyEnabled,\n    isValid: !isProxyEnabled,\n  });\n  const formStateRef = React.useRef(formState);\n  const observerRef = React.useRef<MutationObserver | undefined>();\n  const {\n    isOnBlur: isReValidateOnBlur,\n    isOnChange: isReValidateOnChange,\n  } = React.useRef(modeChecker(reValidateMode)).current;\n\n  contextRef.current = context;\n  resolverRef.current = resolver;\n  formStateRef.current = formState;\n\n  const updateFormState = React.useCallback(\n    (state: Partial<FormState<TFieldValues>> = {}) =>\n      !isUnMount.current &&\n      setFormState({\n        ...formStateRef.current,\n        ...state,\n      }),\n    [],\n  );\n\n  const shouldRenderBaseOnError = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      error: FieldError | undefined,\n      shouldRender: boolean | null = false,\n      state: {\n        dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n        isDirty?: boolean;\n        touched?: FieldNamesMarkedBoolean<TFieldValues>;\n      } = {},\n      isValid?: boolean,\n    ): boolean | void => {\n      let shouldReRender =\n        shouldRender ||\n        isErrorStateChanged<TFieldValues>({\n          errors: formStateRef.current.errors,\n          error,\n          name,\n          validFields: validFieldsRef.current,\n          fieldsWithValidation: fieldsWithValidationRef.current,\n        });\n      const previousError = get(formStateRef.current.errors, name);\n\n      if (error) {\n        unset(validFieldsRef.current, name);\n        shouldReRender =\n          shouldReRender ||\n          !previousError ||\n          !deepEqual(previousError, error, true);\n        set(formStateRef.current.errors, name, error);\n      } else {\n        if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\n          set(validFieldsRef.current, name, true);\n          shouldReRender = shouldReRender || previousError;\n        }\n\n        unset(formStateRef.current.errors, name);\n      }\n\n      if (\n        (shouldReRender && !isNullOrUndefined(shouldRender)) ||\n        !isEmptyObject(state)\n      ) {\n        updateFormState({\n          ...state,\n          errors: formStateRef.current.errors,\n          ...(resolverRef.current ? { isValid: !!isValid } : {}),\n        });\n      }\n    },\n    [],\n  );\n\n  const setFieldValue = React.useCallback(\n    (\n      name: string,\n      rawValue:\n        | FieldValue<TFieldValues>\n        | UnpackNestedValue<DeepPartial<TFieldValues>>\n        | string[]\n        | undefined\n        | null\n        | boolean,\n    ) => {\n      const { ref, options } = fieldsRef.current[name] as Field;\n      const value =\n        isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\n          ? ''\n          : rawValue;\n\n      if (isRadioInput(ref) && options) {\n        options.forEach(\n          ({ ref: radioRef }: { ref: HTMLInputElement }) =>\n            (radioRef.checked = radioRef.value === value),\n        );\n      } else if (isFileInput(ref) && !isString(value)) {\n        ref.files = value as FileList;\n      } else if (isMultipleSelect(ref)) {\n        [...ref.options].forEach(\n          (selectRef) =>\n            (selectRef.selected = (value as string[]).includes(\n              selectRef.value,\n            )),\n        );\n      } else if (isCheckBoxInput(ref) && options) {\n        options.length > 1\n          ? options.forEach(\n              ({ ref: checkboxRef }) =>\n                (checkboxRef.checked = Array.isArray(value)\n                  ? !!(value as []).find(\n                      (data: string) => data === checkboxRef.value,\n                    )\n                  : value === checkboxRef.value),\n            )\n          : (options[0].ref.checked = !!value);\n      } else {\n        ref.value = value;\n      }\n    },\n    [],\n  );\n\n  const isFormDirty = React.useCallback(\n    (name?: string, data?: unknown[]): boolean => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const formValues = getValues();\n\n        name && data && set(formValues, name, data);\n\n        return !deepEqual(\n          formValues,\n          isEmptyObject(defaultValuesRef.current)\n            ? defaultValuesAtRenderRef.current\n            : defaultValuesRef.current,\n        );\n      }\n\n      return false;\n    },\n    [],\n  );\n\n  const updateAndGetDirtyState = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      shouldRender = true,\n    ): {\n      dirtyFields?: FieldNamesMarkedBoolean<TFieldValues>;\n      isDirty?: boolean;\n      touched?: FieldNamesMarkedBoolean<TFieldValues>;\n    } => {\n      if (\n        readFormStateRef.current.isDirty ||\n        readFormStateRef.current.dirtyFields\n      ) {\n        const isFieldDirty = !deepEqual(\n          get(defaultValuesAtRenderRef.current, name),\n          getFieldValue(fieldsRef, name, shallowFieldsStateRef),\n        );\n        const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\n        const previousIsDirty = formStateRef.current.isDirty;\n\n        isFieldDirty\n          ? set(formStateRef.current.dirtyFields, name, true)\n          : unset(formStateRef.current.dirtyFields, name);\n\n        const state = {\n          isDirty: isFormDirty(),\n          dirtyFields: formStateRef.current.dirtyFields,\n        };\n\n        const isChanged =\n          (readFormStateRef.current.isDirty &&\n            previousIsDirty !== state.isDirty) ||\n          (readFormStateRef.current.dirtyFields &&\n            isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\n\n        if (isChanged && shouldRender) {\n          formStateRef.current = {\n            ...formStateRef.current,\n            ...state,\n          };\n          updateFormState({\n            ...state,\n          });\n        }\n\n        return isChanged ? state : {};\n      }\n\n      return {};\n    },\n    [],\n  );\n\n  const executeValidation = React.useCallback(\n    async (\n      name: InternalFieldName<TFieldValues>,\n      skipReRender?: boolean | null,\n    ): Promise<boolean> => {\n      if (fieldsRef.current[name]) {\n        const error = (\n          await validateField<TFieldValues>(\n            fieldsRef,\n            isValidateAllFieldCriteria,\n            fieldsRef.current[name] as Field,\n            shallowFieldsStateRef,\n          )\n        )[name];\n\n        shouldRenderBaseOnError(name, error, skipReRender);\n\n        return isUndefined(error);\n      }\n\n      return false;\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const executeSchemaOrResolverValidation = React.useCallback(\n    async (\n      names:\n        | InternalFieldName<TFieldValues>\n        | InternalFieldName<TFieldValues>[],\n    ) => {\n      const { errors } = await resolverRef.current!(\n        getValues(),\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const previousFormIsValid = formStateRef.current.isValid;\n\n      if (Array.isArray(names)) {\n        const isInputsValid = names\n          .map((name) => {\n            const error = get(errors, name);\n\n            error\n              ? set(formStateRef.current.errors, name, error)\n              : unset(formStateRef.current.errors, name);\n\n            return !error;\n          })\n          .every(Boolean);\n\n        updateFormState({\n          isValid: isEmptyObject(errors),\n          errors: formStateRef.current.errors,\n        });\n\n        return isInputsValid;\n      } else {\n        const error = get(errors, names);\n\n        shouldRenderBaseOnError(\n          names,\n          error,\n          previousFormIsValid !== isEmptyObject(errors),\n          {},\n          isEmptyObject(errors),\n        );\n\n        return !error;\n      }\n    },\n    [shouldRenderBaseOnError, isValidateAllFieldCriteria],\n  );\n\n  const trigger = React.useCallback(\n    async (\n      name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n    ): Promise<boolean> => {\n      const fields = name || Object.keys(fieldsRef.current);\n\n      if (resolverRef.current) {\n        return executeSchemaOrResolverValidation(fields);\n      }\n\n      if (Array.isArray(fields)) {\n        !name && (formStateRef.current.errors = {});\n        const result = await Promise.all(\n          fields.map(async (data) => await executeValidation(data, null)),\n        );\n        updateFormState();\n        return result.every(Boolean);\n      }\n\n      return await executeValidation(fields, readFormStateRef.current.isValid);\n    },\n    [executeSchemaOrResolverValidation, executeValidation],\n  );\n\n  const setInternalValues = React.useCallback(\n    <T extends string, U extends object | unknown[]>(\n      name: T,\n      value: U,\n      { shouldDirty, shouldValidate }: SetValueConfig,\n    ) => {\n      const data = {};\n      set(data, name, value);\n\n      for (const fieldName of getPath(name, value)) {\n        if (fieldsRef.current[fieldName]) {\n          setFieldValue(fieldName, get(data, fieldName));\n          shouldDirty && updateAndGetDirtyState(fieldName);\n          shouldValidate && trigger(fieldName as FieldName<TFieldValues>);\n        }\n      }\n    },\n    [trigger, setFieldValue, updateAndGetDirtyState],\n  );\n\n  const setInternalValue = React.useCallback(\n    (\n      name: InternalFieldName<TFieldValues>,\n      value: FieldValue<TFieldValues> | null | undefined | boolean,\n      config: SetValueConfig = {},\n    ) => {\n      if (fieldsRef.current[name]) {\n        setFieldValue(name, value);\n        config.shouldDirty && updateAndGetDirtyState(name);\n      } else if (!isPrimitive(value)) {\n        setInternalValues(name, value, config);\n\n        if (fieldArrayNamesRef.current.has(name)) {\n          fieldArrayDefaultValuesRef.current[name] = value;\n          resetFieldArrayFunctionRef.current[name]({\n            [name]: value,\n          } as UnpackNestedValue<DeepPartial<TFieldValues>>);\n\n          if (\n            (readFormStateRef.current.isDirty ||\n              readFormStateRef.current.dirtyFields) &&\n            config.shouldDirty\n          ) {\n            set(\n              formStateRef.current.dirtyFields,\n              name,\n              setFieldArrayDirtyFields(\n                value,\n                get(defaultValuesRef.current, name, []),\n                get(formStateRef.current.dirtyFields, name, []),\n              ),\n            );\n\n            updateFormState({\n              isDirty: !deepEqual(\n                { ...getValues(), [name]: value },\n                defaultValuesRef.current,\n              ),\n              dirtyFields: formStateRef.current.dirtyFields,\n            });\n          }\n        }\n      }\n\n      !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\n    },\n    [updateAndGetDirtyState, setFieldValue, setInternalValues],\n  );\n\n  const isFieldWatched = (name: string) =>\n    isWatchAllRef.current ||\n    watchFieldsRef.current.has(name) ||\n    watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\n\n  const renderWatchedInputs = (name: string, found = true): boolean => {\n    if (!isEmptyObject(useWatchFieldsRef.current)) {\n      for (const key in useWatchFieldsRef.current) {\n        if (\n          !name ||\n          !useWatchFieldsRef.current[key].size ||\n          useWatchFieldsRef.current[key].has(name) ||\n          useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))\n        ) {\n          useWatchRenderFunctionsRef.current[key]();\n          found = false;\n        }\n      }\n    }\n\n    return found;\n  };\n\n  function setValue<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    value: TFieldValue extends NestedValue<infer U>\n      ? U\n      : UnpackNestedValue<DeepPartial<LiteralToPrimitive<TFieldValue>>>,\n    config?: SetValueConfig,\n  ): void {\n    setInternalValue(name, value as TFieldValues[string], config);\n    isFieldWatched(name) && updateFormState();\n    renderWatchedInputs(name);\n    (config || {}).shouldValidate && trigger(name as any);\n  }\n\n  handleChangeRef.current = handleChangeRef.current\n    ? handleChangeRef.current\n    : async ({ type, target }: Event): Promise<void | boolean> => {\n        let name = (target as Ref)!.name;\n        const field = fieldsRef.current[name];\n        let error;\n        let isValid;\n\n        if (field) {\n          const isBlurEvent = type === EVENTS.BLUR;\n          const shouldSkipValidation = skipValidation({\n            isBlurEvent,\n            isReValidateOnChange,\n            isReValidateOnBlur,\n            isTouched: !!get(formStateRef.current.touched, name),\n            isSubmitted: formStateRef.current.isSubmitted,\n            ...modeRef.current,\n          });\n          let state = updateAndGetDirtyState(name, false);\n          let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\n\n          if (\n            isBlurEvent &&\n            !get(formStateRef.current.touched, name) &&\n            readFormStateRef.current.touched\n          ) {\n            set(formStateRef.current.touched, name, true);\n            state = {\n              ...state,\n              touched: formStateRef.current.touched,\n            };\n          }\n\n          if (shouldSkipValidation) {\n            renderWatchedInputs(name);\n            return (\n              (!isEmptyObject(state) ||\n                (shouldRender && isEmptyObject(state))) &&\n              updateFormState(state)\n            );\n          }\n\n          if (resolverRef.current) {\n            const { errors } = await resolverRef.current(\n              getValues(),\n              contextRef.current,\n              isValidateAllFieldCriteria,\n            );\n            const previousFormIsValid = formStateRef.current.isValid;\n            error = get(errors, name);\n\n            if (!error && resolverRef.current) {\n              const parentNodeName = name.substring(\n                0,\n                name.lastIndexOf('.') > name.lastIndexOf('[')\n                  ? name.lastIndexOf('.')\n                  : name.lastIndexOf('['),\n              );\n              const currentError = get(errors, parentNodeName, {});\n              currentError.type &&\n                currentError.message &&\n                (error = currentError);\n\n              if (\n                parentNodeName &&\n                (currentError ||\n                  get(formStateRef.current.errors, parentNodeName))\n              ) {\n                name = parentNodeName;\n              }\n            }\n\n            isValid = isEmptyObject(errors);\n\n            if (previousFormIsValid !== isValid) {\n              shouldRender = true;\n            }\n          } else {\n            error = (\n              await validateField<TFieldValues>(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              )\n            )[name];\n          }\n\n          renderWatchedInputs(name);\n          shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\n        }\n      };\n\n  function setFieldArrayDefaultValues<T extends FieldValues>(data: T): T {\n    if (!shouldUnregister) {\n      let copy = cloneObject(data, isWeb);\n\n      for (const value of fieldArrayNamesRef.current) {\n        if (isKey(value) && !copy[value]) {\n          copy = {\n            ...copy,\n            [value]: [],\n          };\n        }\n      }\n\n      return copy;\n    }\n    return data;\n  }\n\n  function getValues(): UnpackNestedValue<TFieldValues>;\n  function getValues<TFieldName extends string, TFieldValue extends unknown>(\n    name: TFieldName,\n  ): TFieldName extends keyof TFieldValues\n    ? UnpackNestedValue<TFieldValues>[TFieldName]\n    : TFieldValue;\n  function getValues<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function getValues(payload?: string | string[]): unknown {\n    if (isString(payload)) {\n      return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\n    }\n\n    if (Array.isArray(payload)) {\n      const data = {};\n\n      for (const name of payload) {\n        set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\n      }\n\n      return data;\n    }\n\n    return setFieldArrayDefaultValues(\n      getFieldsValues(fieldsRef, shallowFieldsStateRef),\n    );\n  }\n\n  const validateResolver = React.useCallback(\n    async (values = {}) => {\n      const { errors } = await resolverRef.current!(\n        {\n          ...defaultValuesRef.current,\n          ...getValues(),\n          ...values,\n        },\n        contextRef.current,\n        isValidateAllFieldCriteria,\n      );\n      const isValid = isEmptyObject(errors);\n\n      formStateRef.current.isValid !== isValid &&\n        updateFormState({\n          isValid,\n        });\n    },\n    [isValidateAllFieldCriteria],\n  );\n\n  const removeFieldEventListener = React.useCallback(\n    (field: Field, forceDelete?: boolean) =>\n      findRemovedFieldAndRemoveListener(\n        fieldsRef,\n        handleChangeRef.current!,\n        field,\n        shallowFieldsStateRef,\n        shouldUnregister,\n        forceDelete,\n      ),\n    [shouldUnregister],\n  );\n\n  const updateWatchedValue = React.useCallback((name: string) => {\n    if (isWatchAllRef.current) {\n      updateFormState();\n    } else if (watchFieldsRef) {\n      for (const watchField of watchFieldsRef.current) {\n        if (watchField.startsWith(name)) {\n          updateFormState();\n          break;\n        }\n      }\n\n      renderWatchedInputs(name);\n    }\n  }, []);\n\n  const removeFieldEventListenerAndRef = React.useCallback(\n    (field?: Field, forceDelete?: boolean) => {\n      if (field) {\n        removeFieldEventListener(field, forceDelete);\n\n        if (shouldUnregister && !compact(field.options || []).length) {\n          unset(defaultValuesAtRenderRef.current, field.ref.name);\n          unset(validFieldsRef.current, field.ref.name);\n          unset(fieldsWithValidationRef.current, field.ref.name);\n          unset(formStateRef.current.errors, field.ref.name);\n          set(formStateRef.current.dirtyFields, field.ref.name, true);\n\n          updateFormState({\n            errors: formStateRef.current.errors,\n            isDirty: isFormDirty(),\n            dirtyFields: formStateRef.current.dirtyFields,\n          });\n\n          readFormStateRef.current.isValid &&\n            resolverRef.current &&\n            validateResolver();\n          updateWatchedValue(field.ref.name);\n        }\n      }\n    },\n    [validateResolver, removeFieldEventListener],\n  );\n\n  function clearErrors(\n    name?: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    name &&\n      (Array.isArray(name) ? name : [name]).forEach((inputName) =>\n        fieldsRef.current[inputName] && isKey(inputName)\n          ? delete formStateRef.current.errors[inputName]\n          : unset(formStateRef.current.errors, inputName),\n      );\n\n    updateFormState({\n      errors: name ? formStateRef.current.errors : {},\n    });\n  }\n\n  function setError(name: FieldName<TFieldValues>, error: ErrorOption): void {\n    const ref = (fieldsRef.current[name] || {})!.ref;\n\n    set(formStateRef.current.errors, name, {\n      ...error,\n      ref,\n    });\n\n    updateFormState({\n      isValid: false,\n      errors: formStateRef.current.errors,\n    });\n\n    error.shouldFocus && ref && ref.focus && ref.focus();\n  }\n\n  const watchInternal = React.useCallback(\n    (\n      fieldNames?: string | string[],\n      defaultValue?: unknown,\n      watchId?: string,\n    ) => {\n      const watchFields = watchId\n        ? useWatchFieldsRef.current[watchId]\n        : watchFieldsRef.current;\n      const combinedDefaultValues = isUndefined(defaultValue)\n        ? defaultValuesRef.current\n        : defaultValue;\n      let fieldValues = getFieldsValues<TFieldValues>(\n        fieldsRef,\n        shallowFieldsStateRef,\n        false,\n        fieldNames,\n      );\n\n      if (isString(fieldNames)) {\n        if (fieldArrayNamesRef.current.has(fieldNames)) {\n          const fieldArrayValue = get(\n            fieldArrayValuesRef.current,\n            fieldNames,\n            [],\n          );\n          fieldValues =\n            fieldArrayValue.length !==\n              compact(get(fieldValues, fieldNames, [])).length ||\n            !fieldArrayValue.length\n              ? fieldArrayValuesRef.current\n              : fieldValues;\n        }\n\n        return assignWatchFields<TFieldValues>(\n          fieldValues,\n          fieldNames,\n          watchFields,\n          isUndefined(defaultValue)\n            ? get(combinedDefaultValues, fieldNames)\n            : (defaultValue as UnpackNestedValue<DeepPartial<TFieldValues>>),\n          true,\n        );\n      }\n\n      if (Array.isArray(fieldNames)) {\n        return fieldNames.reduce(\n          (previous, name) => ({\n            ...previous,\n            [name]: assignWatchFields<TFieldValues>(\n              fieldValues,\n              name,\n              watchFields,\n              combinedDefaultValues as UnpackNestedValue<\n                DeepPartial<TFieldValues>\n              >,\n            ),\n          }),\n          {},\n        );\n      }\n\n      isWatchAllRef.current = isUndefined(watchId);\n\n      return transformToNestObject(\n        (!isEmptyObject(fieldValues) && fieldValues) ||\n          (combinedDefaultValues as FieldValues),\n      );\n    },\n    [],\n  );\n\n  function watch(): UnpackNestedValue<TFieldValues>;\n  function watch<\n    TFieldName extends string,\n    TFieldValue extends TFieldValues[TFieldName]\n  >(\n    name: TFieldName,\n    defaultValue?: UnpackNestedValue<LiteralToPrimitive<TFieldValue>>,\n  ): UnpackNestedValue<LiteralToPrimitive<TFieldValue>>;\n  function watch<TFieldName extends keyof TFieldValues>(\n    names: TFieldName[],\n    defaultValues?: UnpackNestedValue<\n      DeepPartial<Pick<TFieldValues, TFieldName>>\n    >,\n  ): UnpackNestedValue<Pick<TFieldValues, TFieldName>>;\n  function watch(\n    names: string[],\n    defaultValues?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ): UnpackNestedValue<DeepPartial<TFieldValues>>;\n  function watch(\n    fieldNames?: string | string[],\n    defaultValue?: unknown,\n  ): unknown {\n    return watchInternal(fieldNames, defaultValue);\n  }\n\n  function unregister(\n    name: FieldName<TFieldValues> | FieldName<TFieldValues>[],\n  ): void {\n    for (const fieldName of Array.isArray(name) ? name : [name]) {\n      removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\n    }\n  }\n\n  function registerFieldRef<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: TFieldElement & Ref,\n    validateOptions: ValidationRules | null = {},\n  ): ((name: InternalFieldName<TFieldValues>) => void) | void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!ref.name) {\n        return console.warn(\n          '📋 Field is missing `name` attribute',\n          ref,\n          `https://react-hook-form.com/api#useForm`,\n        );\n      }\n\n      if (\n        fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\n        !RegExp(\n          `^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\n            .replace(/\\[/g, '\\\\[')\n            .replace(/\\]/g, '\\\\]'),\n        ).test(ref.name)\n      ) {\n        return console.warn(\n          '📋 `name` prop should be in object shape: name=\"test[index].name\"',\n          ref,\n          'https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const { name, type, value } = ref;\n    const fieldRefAndValidationOptions = {\n      ref,\n      ...validateOptions,\n    };\n    const fields = fieldsRef.current;\n    const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\n    const compareRef = (currentRef: Ref) =>\n      isWeb && (!isHTMLElement(ref) || currentRef === ref);\n    let field = fields[name] as Field;\n    let isEmptyDefaultValue = true;\n    let defaultValue;\n\n    if (\n      field &&\n      (isRadioOrCheckbox\n        ? Array.isArray(field.options) &&\n          compact(field.options).find((option) => {\n            return value === option.ref.value && compareRef(option.ref);\n          })\n        : compareRef(field.ref))\n    ) {\n      fields[name] = {\n        ...field,\n        ...validateOptions,\n      };\n      return;\n    }\n\n    if (type) {\n      field = isRadioOrCheckbox\n        ? {\n            options: [\n              ...compact((field && field.options) || []),\n              {\n                ref,\n              } as RadioOrCheckboxOption,\n            ],\n            ref: { type, name },\n            ...validateOptions,\n          }\n        : {\n            ...fieldRefAndValidationOptions,\n          };\n    } else {\n      field = fieldRefAndValidationOptions;\n    }\n\n    fields[name] = field;\n\n    const isEmptyUnmountFields = isUndefined(\n      get(shallowFieldsStateRef.current, name),\n    );\n\n    if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\n      defaultValue = get(\n        isEmptyUnmountFields\n          ? defaultValuesRef.current\n          : shallowFieldsStateRef.current,\n        name,\n      );\n      isEmptyDefaultValue = isUndefined(defaultValue);\n\n      if (!isEmptyDefaultValue && !isFieldArray) {\n        setFieldValue(name, defaultValue);\n      }\n    }\n\n    if (!isEmptyObject(validateOptions)) {\n      set(fieldsWithValidationRef.current, name, true);\n\n      if (!isOnSubmit && readFormStateRef.current.isValid) {\n        validateField(\n          fieldsRef,\n          isValidateAllFieldCriteria,\n          field,\n          shallowFieldsStateRef,\n        ).then((error: FieldErrors) => {\n          const previousFormIsValid = formStateRef.current.isValid;\n\n          isEmptyObject(error)\n            ? set(validFieldsRef.current, name, true)\n            : unset(validFieldsRef.current, name);\n\n          if (previousFormIsValid !== isEmptyObject(error)) {\n            updateFormState();\n          }\n        });\n      }\n    }\n\n    if (\n      !defaultValuesAtRenderRef.current[name] &&\n      !(isFieldArray && isEmptyDefaultValue)\n    ) {\n      const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\n      set(\n        defaultValuesAtRenderRef.current,\n        name,\n        isEmptyDefaultValue\n          ? isObject(fieldValue)\n            ? { ...fieldValue }\n            : fieldValue\n          : defaultValue,\n      );\n      !isFieldArray && unset(formStateRef.current.dirtyFields, name);\n    }\n\n    if (type) {\n      attachEventListeners(\n        isRadioOrCheckbox && field.options\n          ? field.options[field.options.length - 1]\n          : field,\n        isRadioOrCheckbox || isSelectInput(ref),\n        handleChangeRef.current,\n      );\n    }\n  }\n\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    rules?: ValidationRules,\n  ): (ref: (TFieldElement & Ref) | null) => void;\n  function register(\n    name: FieldName<TFieldValues>,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    ref: (TFieldElement & Ref) | null,\n    rules?: ValidationRules,\n  ): void;\n  function register<TFieldElement extends FieldElement<TFieldValues>>(\n    refOrValidationOptions?:\n      | FieldName<TFieldValues>\n      | ValidationRules\n      | (TFieldElement & Ref)\n      | null,\n    rules?: ValidationRules,\n  ): ((ref: (TFieldElement & Ref) | null) => void) | void {\n    if (!isWindowUndefined) {\n      if (isString(refOrValidationOptions)) {\n        registerFieldRef({ name: refOrValidationOptions }, rules);\n      } else if (\n        isObject(refOrValidationOptions) &&\n        'name' in refOrValidationOptions\n      ) {\n        registerFieldRef(refOrValidationOptions, rules);\n      } else {\n        return (ref: (TFieldElement & Ref) | null) =>\n          ref && registerFieldRef(ref, refOrValidationOptions);\n      }\n    }\n  }\n\n  const handleSubmit = React.useCallback(\n    <TSubmitFieldValues extends FieldValues = TFieldValues>(\n      onValid: SubmitHandler<TSubmitFieldValues>,\n      onInvalid?: SubmitErrorHandler<TFieldValues>,\n    ) => async (e?: React.BaseSyntheticEvent): Promise<void> => {\n      if (e && e.preventDefault) {\n        e.preventDefault();\n        e.persist();\n      }\n      let fieldErrors: FieldErrors<TFieldValues> = {};\n      let fieldValues = setFieldArrayDefaultValues(\n        getFieldsValues(fieldsRef, shallowFieldsStateRef, true),\n      );\n\n      readFormStateRef.current.isSubmitting &&\n        updateFormState({\n          isSubmitting: true,\n        });\n\n      try {\n        if (resolverRef.current) {\n          const { errors, values } = await resolverRef.current(\n            fieldValues,\n            contextRef.current,\n            isValidateAllFieldCriteria,\n          );\n          formStateRef.current.errors = fieldErrors = errors;\n          fieldValues = values;\n        } else {\n          for (const field of Object.values(fieldsRef.current)) {\n            if (field) {\n              const {\n                ref: { name },\n              } = field;\n\n              const fieldError = await validateField(\n                fieldsRef,\n                isValidateAllFieldCriteria,\n                field,\n                shallowFieldsStateRef,\n              );\n\n              if (fieldError[name]) {\n                set(fieldErrors, name, fieldError[name]);\n                unset(validFieldsRef.current, name);\n              } else if (get(fieldsWithValidationRef.current, name)) {\n                unset(formStateRef.current.errors, name);\n                set(validFieldsRef.current, name, true);\n              }\n            }\n          }\n        }\n\n        if (\n          isEmptyObject(fieldErrors) &&\n          Object.keys(formStateRef.current.errors).every(\n            (name) => name in fieldsRef.current,\n          )\n        ) {\n          updateFormState({\n            errors: {},\n            isSubmitting: true,\n          });\n          await onValid(fieldValues, e);\n        } else {\n          formStateRef.current.errors = {\n            ...formStateRef.current.errors,\n            ...fieldErrors,\n          };\n          onInvalid && (await onInvalid(formStateRef.current.errors, e));\n          shouldFocusError &&\n            focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\n        }\n      } finally {\n        updateFormState({\n          isSubmitted: true,\n          isSubmitting: false,\n          isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\n          errors: formStateRef.current.errors,\n          submitCount: formStateRef.current.submitCount + 1,\n        });\n      }\n    },\n    [shouldFocusError, isValidateAllFieldCriteria],\n  );\n\n  const resetRefs = ({\n    errors,\n    isDirty,\n    isSubmitted,\n    touched,\n    isValid,\n    submitCount,\n    dirtyFields,\n  }: OmitResetState) => {\n    if (!isValid) {\n      validFieldsRef.current = {};\n      fieldsWithValidationRef.current = {};\n    }\n\n    defaultValuesAtRenderRef.current = {};\n    fieldArrayDefaultValuesRef.current = {};\n    watchFieldsRef.current = new Set();\n    isWatchAllRef.current = false;\n\n    updateFormState({\n      submitCount: submitCount ? formStateRef.current.submitCount : 0,\n      isDirty: isDirty ? formStateRef.current.isDirty : false,\n      isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\n      isValid: isValid ? formStateRef.current.isValid : false,\n      dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\n      touched: touched ? formStateRef.current.touched : {},\n      errors: errors ? formStateRef.current.errors : {},\n      isSubmitting: false,\n      isSubmitSuccessful: false,\n    });\n  };\n\n  const reset = (\n    values?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n    omitResetState: OmitResetState = {},\n  ): void => {\n    if (isWeb) {\n      for (const field of Object.values(fieldsRef.current)) {\n        if (field) {\n          const { ref, options } = field;\n          const inputRef =\n            isRadioOrCheckboxFunction(ref) && Array.isArray(options)\n              ? options[0].ref\n              : ref;\n\n          if (isHTMLElement(inputRef)) {\n            try {\n              inputRef.closest('form')!.reset();\n              break;\n            } catch {}\n          }\n        }\n      }\n    }\n\n    fieldsRef.current = {};\n    defaultValuesRef.current = cloneObject(\n      values || defaultValuesRef.current,\n      isWeb,\n    );\n    values && renderWatchedInputs('');\n\n    Object.values(resetFieldArrayFunctionRef.current).forEach(\n      (resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray(),\n    );\n\n    shallowFieldsStateRef.current = shouldUnregister\n      ? {}\n      : cloneObject(values, isWeb) || {};\n\n    resetRefs(omitResetState);\n  };\n\n  React.useEffect(() => {\n    isUnMount.current = false;\n    resolver && readFormStateRef.current.isValid && validateResolver();\n\n    observerRef.current =\n      observerRef.current || !isWeb\n        ? observerRef.current\n        : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\n\n    return () => {\n      isUnMount.current = true;\n      observerRef.current && observerRef.current.disconnect();\n      shallowFieldsStateRef.current = {};\n\n      if (process.env.NODE_ENV !== 'production') {\n        return;\n      }\n\n      Object.values(fieldsRef.current).forEach((field) =>\n        removeFieldEventListenerAndRef(field, true),\n      );\n    };\n  }, [removeFieldEventListenerAndRef]);\n\n  if (!resolver && readFormStateRef.current.isValid) {\n    formState.isValid =\n      deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\n      isEmptyObject(formStateRef.current.errors);\n  }\n\n  const commonProps = {\n    trigger,\n    setValue: React.useCallback(setValue, [setInternalValue, trigger]),\n    getValues: React.useCallback(getValues, []),\n    register: React.useCallback(register, [defaultValuesRef.current]),\n    unregister: React.useCallback(unregister, []),\n  };\n\n  const control = React.useMemo(\n    () => ({\n      isFormDirty,\n      updateWatchedValue,\n      shouldUnregister,\n      updateFormState,\n      removeFieldEventListener,\n      watchInternal,\n      mode: modeRef.current,\n      reValidateMode: {\n        isReValidateOnBlur,\n        isReValidateOnChange,\n      },\n      validateResolver: resolver ? validateResolver : undefined,\n      fieldsRef,\n      resetFieldArrayFunctionRef,\n      useWatchFieldsRef,\n      useWatchRenderFunctionsRef,\n      fieldArrayDefaultValuesRef,\n      validFieldsRef,\n      fieldsWithValidationRef,\n      fieldArrayNamesRef,\n      readFormStateRef,\n      formStateRef,\n      defaultValuesRef,\n      shallowFieldsStateRef,\n      fieldArrayValuesRef,\n      ...commonProps,\n    }),\n    [\n      defaultValuesRef.current,\n      updateWatchedValue,\n      shouldUnregister,\n      removeFieldEventListener,\n      watchInternal,\n    ],\n  );\n\n  return {\n    watch,\n    control,\n    formState: isProxyEnabled\n      ? new Proxy(formState, {\n          get: (obj, prop: keyof FormStateProxy) => {\n            if (process.env.NODE_ENV !== 'production') {\n              if (prop === 'isValid' && isOnSubmit) {\n                console.warn(\n                  '📋 `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState',\n                );\n              }\n            }\n\n            if (prop in obj) {\n              readFormStateRef.current[prop] = true;\n              return obj[prop];\n            }\n\n            return undefined;\n          },\n        })\n      : formState,\n    handleSubmit,\n    reset: React.useCallback(reset, []),\n    clearErrors: React.useCallback(clearErrors, []),\n    setError: React.useCallback(setError, []),\n    errors: formState.errors,\n    ...commonProps,\n  };\n}\n","import * as React from 'react';\nimport { UseFormMethods, FieldValues, FormProviderProps } from './types';\n\nconst FormContext = React.createContext<UseFormMethods | null>(null);\n\nFormContext.displayName = 'RHFContext';\n\nexport const useFormContext = <\n  TFieldValues extends FieldValues\n>(): UseFormMethods<TFieldValues> =>\n  React.useContext(FormContext) as UseFormMethods<TFieldValues>;\n\nexport const FormProvider = <TFieldValues extends FieldValues>({\n  children,\n  ...props\n}: FormProviderProps<TFieldValues>) => (\n  <FormContext.Provider value={{ ...props } as UseFormMethods}>\n    {children}\n  </FormContext.Provider>\n);\n","import { UNDEFINED } from '../constants';\n\nexport default () => {\n  const d =\n    typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16 + d) % 16 | 0;\n\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n};\n","import isUndefined from './isUndefined';\nimport compact from './compact';\n\nconst removeAt = <T>(data: T[], index: number): T[] => [\n  ...data.slice(0, index),\n  ...data.slice(index + 1),\n];\n\nfunction removeAtIndexes<T>(data: T[], index: number[]): T[] {\n  let k = -1;\n\n  while (++k < data.length) {\n    if (index.indexOf(k) >= 0) {\n      delete data[k];\n    }\n  }\n\n  return compact(data);\n}\n\nexport default <T>(data: T[], index?: number | number[]): T[] =>\n  isUndefined(index)\n    ? []\n    : Array.isArray(index)\n    ? removeAtIndexes(data, index)\n    : removeAt(data, index);\n","import isUndefined from './isUndefined';\n\nexport default <T>(\n  data: (T | undefined)[],\n  from: number,\n  to: number,\n): (T | undefined)[] => {\n  if (Array.isArray(data)) {\n    if (isUndefined(data[to])) {\n      data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n  }\n\n  return [];\n};\n","export default <T>(data: T[], indexA: number, indexB: number): void => {\n  const temp = [data[indexB], data[indexA]];\n  data[indexA] = temp[0];\n  data[indexB] = temp[1];\n};\n","export default function prepend<T>(data: T[]): (T | undefined)[];\nexport default function prepend<T>(data: T[], value: T | T[]): T[];\nexport default function prepend<T>(\n  data: T[],\n  value?: T | T[],\n): (T | undefined)[] {\n  return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\n}\n","export default function insert<T>(data: T[], index: number): (T | undefined)[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value: T | T[],\n): T[];\nexport default function insert<T>(\n  data: T[],\n  index: number,\n  value?: T | T[],\n): (T | undefined)[] {\n  return [\n    ...data.slice(0, index),\n    ...(Array.isArray(value) ? value : [value || undefined]),\n    ...data.slice(index),\n  ];\n}\n","export default <T>(value: T | T[]): undefined[] | undefined =>\n  Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n","import isObject from './isObject';\n\nfunction mapValueToBoolean<U>(value: U): boolean[] | Record<string, boolean>[] {\n  if (isObject(value)) {\n    const object: Record<string, boolean> = {};\n\n    for (const key in value) {\n      object[key] = true;\n    }\n\n    return [object];\n  }\n\n  return [true];\n}\n\nexport default <T>(value: T) =>\n  ((Array.isArray(value) ? value : [value]) as T[])\n    .map(mapValueToBoolean)\n    .flat();\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport { isMatchFieldArrayName } from './logic/isNameInFieldArray';\nimport generateId from './logic/generateId';\nimport getFieldArrayParentName from './logic/getFieldArrayParentName';\nimport get from './utils/get';\nimport set from './utils/set';\nimport removeArrayAt from './utils/remove';\nimport unset from './utils/unset';\nimport moveArrayAt from './utils/move';\nimport swapArrayAt from './utils/swap';\nimport prependAt from './utils/prepend';\nimport insertAt from './utils/insert';\nimport fillEmptyArray from './utils/fillEmptyArray';\nimport fillBooleanArray from './utils/fillBooleanArray';\nimport compact from './utils/compact';\nimport {\n  Field,\n  FieldValues,\n  UseFieldArrayOptions,\n  Control,\n  ArrayField,\n  UnpackNestedValue,\n  DeepPartial,\n  UseFieldArrayMethods,\n} from './types';\n\nconst mapIds = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id'\n>(\n  values: Partial<TFieldArrayValues>[] = [],\n  keyName: TKeyName,\n): Partial<ArrayField<TFieldArrayValues, TKeyName>>[] => {\n  if (process.env.NODE_ENV !== 'production') {\n    for (const value of values) {\n      if (!!value && keyName in value) {\n        console.warn(\n          `📋 useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`,\n        );\n\n        break;\n      }\n    }\n  }\n\n  return values.map((value: Partial<TFieldArrayValues>) => ({\n    [keyName]: generateId(),\n    ...value,\n  }));\n};\n\nexport const useFieldArray = <\n  TFieldArrayValues extends FieldValues = FieldValues,\n  TKeyName extends string = 'id',\n  TControl extends Control = Control\n>({\n  control,\n  name,\n  keyName = 'id' as TKeyName,\n}: UseFieldArrayOptions<TKeyName, TControl>): UseFieldArrayMethods<\n  TFieldArrayValues,\n  TKeyName\n> => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray',\n      );\n    }\n  }\n\n  const focusIndexRef = React.useRef(-1);\n  const {\n    isFormDirty,\n    updateWatchedValue,\n    resetFieldArrayFunctionRef,\n    fieldArrayNamesRef,\n    fieldsRef,\n    defaultValuesRef,\n    removeFieldEventListener,\n    formStateRef,\n    shallowFieldsStateRef,\n    updateFormState,\n    readFormStateRef,\n    validFieldsRef,\n    fieldsWithValidationRef,\n    fieldArrayDefaultValuesRef,\n    validateResolver,\n    getValues,\n    shouldUnregister,\n    fieldArrayValuesRef,\n  } = control || methods.control;\n\n  const fieldArrayParentName = getFieldArrayParentName(name);\n  const memoizedDefaultValues = React.useRef<Partial<TFieldArrayValues>[]>([\n    ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\n      ? get(fieldArrayDefaultValuesRef.current, name, [])\n      : get(\n          shouldUnregister\n            ? defaultValuesRef.current\n            : shallowFieldsStateRef.current,\n          name,\n          [],\n        )),\n  ]);\n  const [fields, setFields] = React.useState<\n    Partial<ArrayField<TFieldArrayValues, TKeyName>>[]\n  >(mapIds(memoizedDefaultValues.current, keyName));\n  set(fieldArrayValuesRef.current, name, fields);\n\n  const getFieldArrayValue = React.useCallback(\n    () => get(fieldArrayValuesRef.current, name, []),\n    [],\n  );\n\n  const getCurrentFieldsValues = () =>\n    get(getValues(), name, getFieldArrayValue()).map(\n      (item: Partial<TFieldArrayValues>, index: number) => ({\n        ...getFieldArrayValue()[index],\n        ...item,\n      }),\n    );\n\n  fieldArrayNamesRef.current.add(name);\n\n  if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\n    set(\n      fieldArrayDefaultValuesRef.current,\n      fieldArrayParentName,\n      get(defaultValuesRef.current, fieldArrayParentName),\n    );\n  }\n\n  const setFieldAndValidState = (\n    fieldsValues: Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n  ) => {\n    setFields(fieldsValues);\n    set(fieldArrayValuesRef.current, name, fieldsValues);\n\n    if (readFormStateRef.current.isValid && validateResolver) {\n      const values = getValues();\n      set(values, name, fieldsValues);\n      validateResolver(values);\n    }\n  };\n\n  const resetFields = () => {\n    for (const key in fieldsRef.current) {\n      isMatchFieldArrayName(key, name) &&\n        removeFieldEventListener(fieldsRef.current[key] as Field, true);\n    }\n  };\n\n  const cleanup = <T>(ref: T) =>\n    !compact(get(ref, name, [])).length && unset(ref, name);\n\n  const updateDirtyFieldsWithDefaultValues = <\n    T extends { [k: string]: unknown }[]\n  >(\n    updatedFieldArrayValues?: T,\n  ) => {\n    const defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\n    const updateDirtyFieldsBaseOnDefaultValues = <U extends T>(\n      base: U,\n      target: U,\n    ) => {\n      for (const key in base) {\n        for (const innerKey in base[key]) {\n          if (\n            innerKey !== keyName &&\n            (!target[key] ||\n              !base[key] ||\n              base[key][innerKey] !== target[key][innerKey])\n          ) {\n            set(formStateRef.current.dirtyFields, `${name}[${key}]`, {\n              ...get(formStateRef.current.dirtyFields, `${name}[${key}]`, {}),\n              [innerKey]: true,\n            });\n          }\n        }\n      }\n    };\n\n    if (updatedFieldArrayValues) {\n      updateDirtyFieldsBaseOnDefaultValues(\n        defaultFieldArrayValues,\n        updatedFieldArrayValues,\n      );\n      updateDirtyFieldsBaseOnDefaultValues(\n        updatedFieldArrayValues,\n        defaultFieldArrayValues,\n      );\n    }\n  };\n\n  const batchStateUpdate = <\n    T extends Function,\n    K extends { [k: string]: unknown }[]\n  >(\n    method: T,\n    args: {\n      argA?: unknown;\n      argB?: unknown;\n      argC?: unknown;\n      argD?: unknown;\n    },\n    updatedFieldValues?: K,\n    updatedFormValues: (Partial<TFieldArrayValues> | undefined)[] = [],\n    shouldSet = true,\n    shouldUpdateValid = false,\n  ) => {\n    if (get(shallowFieldsStateRef.current, name)) {\n      const output = method(\n        get(shallowFieldsStateRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(shallowFieldsStateRef.current, name, output);\n    }\n\n    if (get(fieldArrayDefaultValuesRef.current, name)) {\n      const output = method(\n        get(fieldArrayDefaultValuesRef.current, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\n      cleanup(fieldArrayDefaultValuesRef.current);\n    }\n\n    if (Array.isArray(get(formStateRef.current.errors, name))) {\n      const output = method(\n        get(formStateRef.current.errors, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.errors, name, output);\n      cleanup(formStateRef.current.errors);\n    }\n\n    if (\n      readFormStateRef.current.touched &&\n      get(formStateRef.current.touched, name)\n    ) {\n      const output = method(\n        get(formStateRef.current.touched, name),\n        args.argA,\n        args.argB,\n      );\n      shouldSet && set(formStateRef.current.touched, name, output);\n      cleanup(formStateRef.current.touched);\n    }\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      const output = method(\n        get(formStateRef.current.dirtyFields, name, []),\n        args.argC,\n        args.argD,\n      );\n      shouldSet && set(formStateRef.current.dirtyFields, name, output);\n      updateDirtyFieldsWithDefaultValues(updatedFieldValues);\n      cleanup(formStateRef.current.dirtyFields);\n    }\n\n    if (\n      shouldUpdateValid &&\n      readFormStateRef.current.isValid &&\n      !validateResolver\n    ) {\n      set(\n        validFieldsRef.current,\n        name,\n        method(get(validFieldsRef.current, name, []), args.argA),\n      );\n      cleanup(validFieldsRef.current);\n\n      set(\n        fieldsWithValidationRef.current,\n        name,\n        method(get(fieldsWithValidationRef.current, name, []), args.argA),\n      );\n      cleanup(fieldsWithValidationRef.current);\n    }\n\n    updateFormState({\n      errors: formStateRef.current.errors,\n      dirtyFields: formStateRef.current.dirtyFields,\n      isDirty: isFormDirty(\n        name,\n        updatedFormValues.map(({ [keyName]: omitted, ...rest } = {}) => rest),\n      ),\n      touched: formStateRef.current.touched,\n    });\n  };\n\n  const append = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const updateFormValues = [\n      ...getFieldArrayValue(),\n      ...mapIds(Array.isArray(value) ? value : [value], keyName),\n    ];\n    setFieldAndValidState(updateFormValues);\n\n    if (\n      readFormStateRef.current.dirtyFields ||\n      readFormStateRef.current.isDirty\n    ) {\n      updateDirtyFieldsWithDefaultValues(updateFormValues);\n\n      updateFormState({\n        isDirty: true,\n        dirtyFields: formStateRef.current.dirtyFields,\n      });\n    }\n\n    !shouldUnregister &&\n      set(shallowFieldsStateRef.current, name, [\n        ...(get(shallowFieldsStateRef.current, name) || []),\n        value,\n      ]);\n    focusIndexRef.current = shouldFocus ? fields.length : -1;\n  };\n\n  const prepend = (\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const updatedFieldArrayValues = prependAt(\n      getCurrentFieldsValues(),\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      prependAt,\n      {\n        argA: emptyArray,\n        argC: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n    );\n    focusIndexRef.current = shouldFocus ? 0 : -1;\n  };\n\n  const remove = (index?: number | number[]) => {\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldValues: { [k: string]: unknown }[] = removeArrayAt(\n      fieldValues,\n      index,\n    );\n    setFieldAndValidState(\n      updatedFieldValues as Partial<ArrayField<TFieldArrayValues, TKeyName>>[],\n    );\n    resetFields();\n    batchStateUpdate(\n      removeArrayAt,\n      {\n        argA: index,\n        argC: index,\n      },\n      updatedFieldValues,\n      removeArrayAt(fieldValues, index),\n      true,\n      true,\n    );\n  };\n\n  const insert = (\n    index: number,\n    value: Partial<TFieldArrayValues> | Partial<TFieldArrayValues>[],\n    shouldFocus = true,\n  ) => {\n    const emptyArray = fillEmptyArray(value);\n    const fieldValues = getCurrentFieldsValues();\n    const updatedFieldArrayValues = insertAt(\n      fieldValues,\n      index,\n      mapIds(Array.isArray(value) ? value : [value], keyName),\n    );\n\n    setFieldAndValidState(updatedFieldArrayValues);\n    resetFields();\n    batchStateUpdate(\n      insertAt,\n      {\n        argA: index,\n        argB: emptyArray,\n        argC: index,\n        argD: fillBooleanArray(value),\n      },\n      updatedFieldArrayValues,\n      insertAt(fieldValues, index),\n    );\n    focusIndexRef.current = shouldFocus ? index : -1;\n  };\n\n  const swap = (indexA: number, indexB: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    swapArrayAt(fieldValues, indexA, indexB);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      swapArrayAt,\n      {\n        argA: indexA,\n        argB: indexB,\n        argC: indexA,\n        argD: indexB,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  const move = (from: number, to: number) => {\n    const fieldValues = getCurrentFieldsValues();\n    moveArrayAt(fieldValues, from, to);\n    resetFields();\n    setFieldAndValidState([...fieldValues]);\n    batchStateUpdate(\n      moveArrayAt,\n      {\n        argA: from,\n        argB: to,\n        argC: from,\n        argD: to,\n      },\n      undefined,\n      fieldValues,\n      false,\n    );\n  };\n\n  const reset = <TFieldValues>(\n    data?: UnpackNestedValue<DeepPartial<TFieldValues>>,\n  ) => {\n    resetFields();\n    !data && unset(fieldArrayDefaultValuesRef.current, name);\n    unset(shallowFieldsStateRef.current, name);\n    memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\n    setFields(mapIds(memoizedDefaultValues.current, keyName));\n  };\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!name) {\n        console.warn(\n          '📋 useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray',\n        );\n      }\n    }\n\n    const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\n\n    if (defaultValues && fields.length < defaultValues.length) {\n      defaultValues.pop();\n      set(fieldArrayDefaultValuesRef.current, name, defaultValues);\n    }\n\n    updateWatchedValue(name);\n\n    if (focusIndexRef.current > -1) {\n      for (const key in fieldsRef.current) {\n        const field = fieldsRef.current[key];\n        if (\n          key.startsWith(`${name}[${focusIndexRef.current}]`) &&\n          field!.ref.focus\n        ) {\n          field!.ref.focus();\n          break;\n        }\n      }\n    }\n\n    focusIndexRef.current = -1;\n  }, [fields, name]);\n\n  React.useEffect(() => {\n    const resetFunctions = resetFieldArrayFunctionRef.current;\n    const fieldArrayNames = fieldArrayNamesRef.current;\n\n    if (!getFieldArrayParentName(name)) {\n      resetFunctions[name] = reset;\n    }\n\n    return () => {\n      resetFields();\n      delete resetFunctions[name];\n      unset(fieldArrayValuesRef, name);\n      fieldArrayNames.delete(name);\n    };\n  }, []);\n\n  return {\n    swap: React.useCallback(swap, [name]),\n    move: React.useCallback(move, [name]),\n    prepend: React.useCallback(prepend, [name]),\n    append: React.useCallback(append, [name]),\n    remove: React.useCallback(remove, [name]),\n    insert: React.useCallback(insert, [name]),\n    fields,\n  };\n};\n","import * as React from 'react';\nimport { useFormContext } from './useFormContext';\nimport isUndefined from './utils/isUndefined';\nimport isString from './utils/isString';\nimport generateId from './logic/generateId';\nimport get from './utils/get';\nimport isObject from './utils/isObject';\nimport {\n  DeepPartial,\n  UseWatchOptions,\n  FieldValues,\n  UnpackNestedValue,\n  Control,\n} from './types';\n\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  control?: Control;\n}): undefined | UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValue extends any>(props: {\n  name: string;\n  defaultValue: UnpackNestedValue<TWatchFieldValue>;\n  control?: Control;\n}): UnpackNestedValue<TWatchFieldValue>;\nexport function useWatch<TWatchFieldValues extends FieldValues>(props: {\n  name: string[];\n  defaultValue?: UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\n  control?: Control;\n}): UnpackNestedValue<DeepPartial<TWatchFieldValues>>;\nexport function useWatch<TWatchFieldValues>({\n  control,\n  name,\n  defaultValue,\n}: UseWatchOptions): TWatchFieldValues {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch',\n      );\n    }\n  }\n\n  const {\n    useWatchFieldsRef,\n    useWatchRenderFunctionsRef,\n    watchInternal,\n    defaultValuesRef,\n  } = control || methods.control;\n  const [value, setValue] = React.useState<unknown>(\n    isUndefined(defaultValue)\n      ? isString(name)\n        ? get(defaultValuesRef.current, name)\n        : Array.isArray(name)\n        ? name.reduce(\n            (previous, inputName) => ({\n              ...previous,\n              [inputName]: get(defaultValuesRef.current, inputName),\n            }),\n            {},\n          )\n        : defaultValuesRef.current\n      : defaultValue,\n  );\n  const idRef = React.useRef<string>();\n  const defaultValueRef = React.useRef(defaultValue);\n\n  const updateWatchValue = React.useCallback(() => {\n    const value = watchInternal(name, defaultValueRef.current, idRef.current);\n    setValue(\n      isObject(value)\n        ? { ...value }\n        : Array.isArray(value)\n        ? [...value]\n        : value,\n    );\n  }, [setValue, watchInternal, defaultValueRef, name, idRef]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (name === '') {\n        console.warn(\n          '📋 useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch',\n        );\n      }\n    }\n\n    const id = (idRef.current = generateId());\n    const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\n    const watchFieldsHook = useWatchFieldsRef.current;\n    watchFieldsHook[id] = new Set();\n    watchFieldsHookRender[id] = updateWatchValue;\n    watchInternal(name, defaultValueRef.current, id);\n\n    return () => {\n      delete watchFieldsHook[id];\n      delete watchFieldsHookRender[id];\n    };\n  }, [\n    name,\n    updateWatchValue,\n    useWatchRenderFunctionsRef,\n    useWatchFieldsRef,\n    watchInternal,\n    defaultValueRef,\n  ]);\n\n  return (isUndefined(value) ? defaultValue : value) as TWatchFieldValues;\n}\n","import isUndefined from '../utils/isUndefined';\nimport isObject from '../utils/isObject';\nimport isPrimitive from '../utils/isPrimitive';\n\nexport default (event: any) =>\n  isPrimitive(event) ||\n  !isObject(event.target) ||\n  (isObject(event.target) && !event.type)\n    ? event\n    : isUndefined(event.target.value)\n    ? event.target.checked\n    : event.target.value;\n","import * as React from 'react';\nimport isUndefined from './utils/isUndefined';\nimport get from './utils/get';\nimport set from './utils/set';\nimport getInputValue from './logic/getInputValue';\nimport skipValidation from './logic/skipValidation';\nimport isNameInFieldArray from './logic/isNameInFieldArray';\nimport { useFormContext } from './useFormContext';\nimport { VALUE } from './constants';\nimport { Control } from './types';\nimport { ControllerProps } from './types';\n\nconst Controller = <\n  TAs extends\n    | React.ReactElement\n    | React.ComponentType<any>\n    | 'input'\n    | 'select'\n    | 'textarea',\n  TControl extends Control = Control\n>({\n  name,\n  rules,\n  as,\n  render,\n  defaultValue,\n  control,\n  onFocus,\n  ...rest\n}: ControllerProps<TAs, TControl>) => {\n  const methods = useFormContext();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!control && !methods) {\n      throw new Error(\n        '📋 Controller is missing `control` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n  }\n\n  const {\n    defaultValuesRef,\n    setValue,\n    register,\n    unregister,\n    trigger,\n    mode,\n    reValidateMode: { isReValidateOnBlur, isReValidateOnChange },\n    formStateRef: {\n      current: { isSubmitted, touched },\n    },\n    updateFormState,\n    readFormStateRef,\n    fieldsRef,\n    fieldArrayNamesRef,\n    shallowFieldsStateRef,\n  } = control || methods.control;\n  const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\n  const getInitialValue = () =>\n    !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\n      ? get(shallowFieldsStateRef.current, name)\n      : isUndefined(defaultValue)\n      ? get(defaultValuesRef.current, name)\n      : defaultValue;\n  const [value, setInputStateValue] = React.useState(getInitialValue());\n  const valueRef = React.useRef(value);\n  const ref = React.useRef({\n    focus: () => null,\n  });\n  const onFocusRef = React.useRef(onFocus || (() => ref.current.focus()));\n\n  const shouldValidate = React.useCallback(\n    (isBlurEvent?: boolean) =>\n      !skipValidation({\n        isBlurEvent,\n        isReValidateOnBlur,\n        isReValidateOnChange,\n        isSubmitted,\n        isTouched: !!get(touched, name),\n        ...mode,\n      }),\n    [\n      isReValidateOnBlur,\n      isReValidateOnChange,\n      isSubmitted,\n      touched,\n      name,\n      mode,\n    ],\n  );\n\n  const commonTask = React.useCallback(([event]: any[]) => {\n    const data = getInputValue(event);\n    setInputStateValue(data);\n    valueRef.current = data;\n    return data;\n  }, []);\n\n  const registerField = React.useCallback(() => {\n    if (process.env.NODE_ENV !== 'production' && !name) {\n      return console.warn(\n        '📋 Field is missing `name` prop. https://react-hook-form.com/api#Controller',\n      );\n    }\n\n    if (fieldsRef.current[name]) {\n      fieldsRef.current[name] = {\n        ref: fieldsRef.current[name]!.ref,\n        ...rules,\n      };\n    } else {\n      register(\n        Object.defineProperty(\n          {\n            name,\n            focus: onFocusRef.current,\n          },\n          VALUE,\n          {\n            set(data) {\n              setInputStateValue(data);\n              valueRef.current = data;\n            },\n            get() {\n              return valueRef.current;\n            },\n          },\n        ),\n        rules,\n      );\n      if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  }, [rules, name, register]);\n\n  React.useEffect(() => () => unregister(name), [unregister, name]);\n\n  React.useEffect(() => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isUndefined(value)) {\n        console.warn(\n          `📋 ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`,\n        );\n      }\n\n      if ((!as && !render) || (as && render)) {\n        console.warn(\n          `📋 ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`,\n        );\n      }\n\n      if (!isNotFieldArray && isUndefined(defaultValue)) {\n        console.warn(\n          '📋 Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller',\n        );\n      }\n    }\n\n    registerField();\n  }, [registerField]);\n\n  React.useEffect(() => {\n    if (!fieldsRef.current[name]) {\n      registerField();\n      if (isNotFieldArray) {\n        setInputStateValue(getInitialValue());\n      }\n    }\n  });\n\n  const onBlur = React.useCallback(() => {\n    if (readFormStateRef.current.touched && !get(touched, name)) {\n      set(touched, name, true);\n      updateFormState({\n        touched,\n      });\n    }\n\n    if (shouldValidate(true)) {\n      trigger(name);\n    }\n  }, [\n    name,\n    touched,\n    updateFormState,\n    shouldValidate,\n    trigger,\n    readFormStateRef,\n  ]);\n\n  const onChange = React.useCallback(\n    (...event: any[]) =>\n      setValue(name, commonTask(event), {\n        shouldValidate: shouldValidate(),\n        shouldDirty: true,\n      }),\n    [setValue, commonTask, name, shouldValidate],\n  );\n\n  const commonProps = {\n    onChange,\n    onBlur,\n    name,\n    value,\n    ref,\n  };\n\n  const props = {\n    ...rest,\n    ...commonProps,\n  };\n\n  return as\n    ? React.isValidElement(as)\n      ? React.cloneElement(as, props)\n      : React.createElement(as as string, props as any)\n    : render\n    ? render(commonProps)\n    : null;\n};\n\nexport { Controller };\n"]},"metadata":{},"sourceType":"module"}